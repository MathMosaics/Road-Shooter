<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Road: Fleet Command</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff0077;
            --neon-purple: #bc13fe;
            --neon-red: #ff3131;
            --neon-yellow: #ffcc00;
            --neon-green: #39ff14;
        }
        body { 
            margin: 0; background: #000; color: #fff; 
            font-family: 'Orbitron', sans-serif; overflow: hidden; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; touch-action: none;
        }
        #game-container {
            position: relative; 
            background: #000; width: 100%; height: 100%;
            max-width: 450px; max-height: 800px; border: 2px solid #222;
            display: flex; flex-direction: column; overflow: hidden;
        }
        canvas { display: block; width: 100%; flex: 1; background: #000; image-rendering: pixelated; }
        
        #control-deck {
            height: 120px; background: linear-gradient(to bottom, #151515, #000);
            border-top: 3px solid var(--neon-blue); position: relative;
            cursor: crosshair; z-index: 30;
        }
        #deck-glow {
            position: absolute; top: 0; height: 6px; width: 120px;
            background: var(--neon-blue); box-shadow: 0 0 30px var(--neon-blue);
            pointer-events: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 20px; box-sizing: border-box; pointer-events: none;
            display: none; justify-content: space-between; z-index: 50;
        }
        .stat-box { 
            background: rgba(0,0,0,0.8); padding: 10px 15px; 
            border-left: 3px solid var(--neon-blue); border-top: 1px solid #333;
        }
        .stat-label { font-size: 10px; color: var(--neon-blue); display: block; text-transform: uppercase; letter-spacing: 2px; }
        .stat-value { font-size: 18px; font-weight: 900; text-shadow: 0 0 10px var(--neon-blue); }
        
        #progression-container {
            position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%);
            width: 85%; pointer-events: none; z-index: 40; display: none;
        }
        .prog-bar-bg { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; border: 1px solid #333; }
        .prog-bar-fill { height: 100%; background: linear-gradient(90deg, var(--neon-blue), #fff); width: 0%; transition: width 0.3s; }

        #tech-indicator {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            color: var(--neon-purple); font-weight: 900; font-size: 12px;
            text-shadow: 0 0 10px var(--neon-purple); display: none;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            z-index: 100; padding: 30px; box-sizing: border-box;
        }
        
        h2 { color: #fff; font-size: 48px; margin: 0; text-shadow: 0 0 30px var(--neon-blue); font-weight: 900; letter-spacing: -2px; }
        p { letter-spacing: 4px; font-weight: 700; color: var(--neon-blue); margin-top: 10px; font-size: 14px; }
        
        .btn {
            padding: 20px 30px; font-size: 16px; font-family: 'Orbitron', sans-serif;
            font-weight: 900; cursor: pointer; border: 2px solid var(--neon-blue);
            background: rgba(0,0,0,0.9); color: var(--neon-blue); width: 100%; text-transform: uppercase;
            margin-top: 15px; transition: all 0.2s; outline: none;
        }
        .btn:hover:not(:disabled) { background: var(--neon-blue); color: #000; box-shadow: 0 0 30px var(--neon-blue); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: #444; color: #444; }

        #boss-ui {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 80%; display: none; z-index: 60;
        }
        .hp-bar-outer { width: 100%; height: 12px; background: #200; border: 2px solid #fff; border-radius: 6px; overflow: hidden; }
        .hp-bar-inner { height: 100%; background: var(--neon-red); width: 100%; transition: width 0.1s; }
        .hp-label { color: #fff; font-size: 10px; font-weight: 900; text-align: center; display: block; margin-bottom: 4px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div style="display: flex; gap: 15px;">
            <div class="stat-box">
                <span class="stat-label">SQUAD</span>
                <span id="squad-display" class="stat-value">1</span>
            </div>
            <div class="stat-box" style="border-color: var(--neon-purple)">
                <span class="stat-label">SECTOR</span>
                <span id="sector-display" class="stat-value">1</span>
            </div>
        </div>
        <div class="stat-box" style="border-color: var(--neon-green)">
            <span class="stat-label">CREDITS</span>
            <span id="credit-display" class="stat-value">0</span>
        </div>
    </div>

    <div id="tech-indicator">ACTIVE: <span id="tech-name">NONE</span></div>

    <div id="progression-container">
        <div class="prog-bar-bg"><div id="prog-fill" class="prog-bar-fill"></div></div>
    </div>

    <div id="boss-ui">
        <span id="boss-title" class="hp-label">BOSS DETECTED</span>
        <div class="hp-bar-outer"><div id="boss-fill" class="hp-bar-inner"></div></div>
    </div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h2>NEON ROAD</h2>
        <p>RECON UNIT ALPHA</p>
        <button class="btn" onclick="game.startCampaign()">Initialize Run</button>
        <button class="btn" style="border-color: var(--neon-purple); color: var(--neon-purple);" onclick="game.openMarket()">Black Market</button>
    </div>

    <div id="market-overlay" class="overlay">
        <h2 style="font-size: 28px;">BLACK MARKET</h2>
        <p>AVAILABLE CREDITS: <span id="market-credits">0</span></p>
        <div id="market-items" style="width: 100%; max-height: 450px; overflow-y: auto; margin: 20px 0;"></div>
        <button class="btn" onclick="game.closeMarket()">Return to Menu</button>
    </div>

    <div id="death-overlay" class="overlay">
        <h2 style="color: var(--neon-red)">SQUAD LOST</h2>
        <p id="death-stats">MISSION FAILURE</p>
        <button class="btn" onclick="game.startCampaign()">New Run</button>
        <button class="btn" onclick="game.showMenu()">Main Menu</button>
    </div>

    <div id="victory-overlay" class="overlay">
        <h2 style="color: var(--neon-green)">SECTOR CLEAR</h2>
        <button class="btn" onclick="game.nextSector()">Advance Sector</button>
        <button class="btn" style="border-color: var(--neon-purple); color: var(--neon-purple);" onclick="game.openMarket()">Visit Market</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="control-deck"><div id="deck-glow"></div></div>
</div>

<script>
/** * AUDIO SYSTEM
 */
const Sound = {
    ctx: null,
    echoBus: null,
    activeOscillators: [],
    
    init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        this.echoBus = this.ctx.createDelay();
        this.echoBus.delayTime.value = 0.2;
        const feedback = this.ctx.createGain();
        feedback.gain.value = 0.3;
        
        this.echoBus.connect(feedback);
        feedback.connect(this.echoBus);
        this.echoBus.connect(this.ctx.destination);
    },

    stopAll() {
        if (!this.ctx) return;
        this.activeOscillators.forEach(osc => { try { osc.stop(); } catch(e) {} });
        this.activeOscillators = [];
    },

    playWeapon(type) {
        if (!this.ctx || !game.active) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        gain.connect(this.ctx.destination);
        gain.connect(this.echoBus);

        let dur = 0.1;

        switch(type) {
            case 'PULSE':
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.08);
                gain.gain.setValueAtTime(0.06, this.ctx.currentTime);
                break;
            case 'BURST':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(440, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                dur = 0.06;
                break;
            case 'PLASMA':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                dur = 0.2;
                break;
            case 'EMP':
                this.playNoise(0.1, 1000, 0.08);
                return;
            default:
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.04, this.ctx.currentTime);
        }

        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        osc.connect(gain);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
        this.activeOscillators.push(osc);
    },

    playHit() {
        if (!this.ctx || !game.active) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.03);
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.03);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.03);
    },

    playNoise(duration, freq, vol) {
        if (!this.ctx) return;
        const noise = this.ctx.createBufferSource();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = freq;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        noise.start();
    },

    playExplosion() {
        if (!this.ctx) return;
        this.playNoise(0.4, 100, 0.2);
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const deck = document.getElementById('control-deck');
const glow = document.getElementById('deck-glow');

const GAME_WIDTH = 450;
const GAME_HEIGHT = 700;
canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

ctx.imageSmoothingEnabled = false;

const DESIGNS = [
    ["  X  X  ", "   XX   ", "  XXXX  ", " XXXXXX ", "XX XX XX", "  XXXX  "],
    ["  X     X  ", "   X   X   ", "  XXXXXXX  ", " XX XXX XX ", "XXXXXXXXXXX", "X XXXXXXX X", "X X     X X", "   XX XX   "],
    ["    XX    ", "   XXXX   ", "  XXXXXX  ", " XX XX XX ", " XXXXXXXX ", "  X XX X  ", " X      X ", "  X    X  "],
    ["  XX  XX  ", " XXXXXXXXX", "XXXXXXXXXX", "XX XXXX XX", "XXXXXXXXXX", "  X XX X  "],
    ["   X  X   ", "  XXXXXX  ", " XX XX XX ", "XXXXXXXXXX", " X      X ", "  X    X  "],
    ["  XXXXXX  ", " XXXXXXXX ", "XXXXXXXXXX", "XXX XX XXX", "XXXXXXXXXX", " X XXXX X ", "  X    X  "],
    ["    XX    ", "  XXXXXX  ", "XXXXXXXXXX", "  XXXXXX  ", "   XXXX   ", "    XX    "],
    [" X      X ", "  X    X  ", "  XXXXXX  ", "XXXXXXXXXX", "XX XXXX XX", "  XXXXXX  ", "   X  X   "],
    [" XXXXXXXX ", "XXXXXXXXXX", "XX  XX  XX", "XXXXXXXXXX", "XXXXXXXXXX", " XX    XX " ],
    ["  XXXXXX  ", " X      X ", " X  XX  X ", " XXXXXXXX ", " X X  X X ", " X      X "],
    [" XX    XX ", "  XX  XX  ", " XXXXXXXX ", "XX XX XX  ", "XXXXXXXXXX", "X  XXXX  X"],
    ["   XXXX   ", "  XXXXXX  ", " XXXXXXXX ", "XX XX XX XX", "XXXXXXXXXXX", "XXX XX XXX", " X      X "]
];

const COLORS = ['#bc13fe', '#00f2ff', '#ff0077', '#ffcc00', '#39ff14', '#ff3131'];

class Game {
    constructor() {
        this.totalCredits = 0;
        this.upgrades = { hull: 0, speed: 0, perma: 0, temp: 0, color: '#00f2ff' };
        this.currentSector = 1;
        this.persistentSquad = 1;
        this.MAX_SQUAD = 15;

        this.stars = Array.from({length: 80}, () => ({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            v: 0.5 + Math.random() * 1.5,
            z: Math.random() * 2 + 1
        }));

        this.menuMobs = Array.from({length: 12}, () => ({
            startX: Math.random() * GAME_WIDTH,
            x: 0,
            y: Math.random() * GAME_HEIGHT,
            v: 0.8 + Math.random() * 0.8,
            offset: Math.random() * Math.PI * 2,
            d: Math.floor(Math.random() * 12),
            c: COLORS[Math.floor(Math.random() * COLORS.length)],
            scale: 1.5
        }));

        this.setupInput();
        this.reset();
        this.showMenu();
        this.loop();
    }

    reset() {
        this.active = false;
        this.frame = 0;
        this.kills = 0;
        this.targetKills = 25 + (this.currentSector * 10);
        this.creditsThisRun = 0;
        this.playerX = GAME_WIDTH / 2;
        this.targetX = GAME_WIDTH / 2;
        this.isFiring = false;
        this.bossActive = false;
        this.eliteActive = false;
        this.entities = [];
        this.bullets = [];
        this.enemyBullets = [];
        this.squad = [];
        this.tech = null;
        this.techTimer = 0;
        this.initSquad();
        this.speedScale = 1.0; 
        this.milestonesReached = { q1: false, q2: false, q3: false };
    }

    updateHUDVisibility(show) {
        const display = show ? 'flex' : 'none';
        document.getElementById('ui-layer').style.display = display;
        document.getElementById('progression-container').style.display = display;
        if(!show) {
            document.getElementById('boss-ui').style.display = 'none';
            document.getElementById('tech-indicator').style.display = 'none';
        }
    }

    initSquad() {
        this.squad = [];
        const baseCount = Math.min(this.MAX_SQUAD, this.persistentSquad);
        for(let i=0; i < baseCount; i++) this.addUnit('player');
        for(let i=0; i < this.upgrades.perma; i++) this.addUnit('perma');
        for(let i=0; i < this.upgrades.temp; i++) this.addUnit('temp');
    }

    addUnit(type) {
        if(this.squad.length >= this.MAX_SQUAD) return;
        let color = this.upgrades.color;
        if(type === 'perma') color = '#bc13fe';
        if(type === 'temp') color = '#ffcc00';
        this.squad.push({
            type, color,
            angle: Math.random() * Math.PI * 2,
            dist: 15 + Math.random() * 20,
            rot: 0.03 + Math.random() * 0.02,
            hp: 1 + this.upgrades.hull,
            x: 0, y: 0
        });
    }

    setupInput() {
        const handleInteraction = (clientX) => {
            const rect = canvas.getBoundingClientRect();
            const relX = (clientX - rect.left) / rect.width;
            this.targetX = Math.max(30, Math.min(GAME_WIDTH - 30, relX * GAME_WIDTH));
            const deckWidth = deck.offsetWidth;
            glow.style.left = (relX * deckWidth - 60) + "px";
        };
        window.addEventListener('touchstart', (e) => { 
            Sound.init();
            if (!this.active) return; 
            this.isFiring = true; handleInteraction(e.touches[0].clientX); 
        }, { passive: false });
        window.addEventListener('touchmove', (e) => { if (!this.active) return; e.preventDefault(); handleInteraction(e.touches[0].clientX); }, { passive: false });
        window.addEventListener('touchend', () => { this.isFiring = false; });
        window.addEventListener('mousedown', (e) => { 
            Sound.init();
            if (!this.active) return; 
            this.isFiring = true; handleInteraction(e.clientX); 
        });
        window.addEventListener('mousemove', (e) => { if (!this.active || !this.isFiring) return; handleInteraction(e.clientX); });
        window.addEventListener('mouseup', () => { this.isFiring = false; });
    }

    startCampaign() { this.currentSector = 1; this.persistentSquad = 1; this.upgrades.temp = 0; this.start(); }
    nextSector() { this.currentSector++; this.persistentSquad = this.squad.filter(u=>u.type==='player').length; this.start(); }
    start() { 
        this.reset(); 
        this.active = true; 
        this.updateHUDVisibility(true); 
        document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none'); 
        document.getElementById('sector-display').innerText = this.currentSector; 
    }

    spawn() {
        const r = Math.random();
        if (this.bossActive || this.eliteActive) {
            if (r < 0.2) this.spawnGate(true); 
            else if (r < 0.3) this.entities.push({ type: 'crate_credit', amt: 500, x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50 });
            return;
        }

        if(r < 0.65) {
            const d = Math.floor(Math.random() * 12);
            const hp = (12 + d*4) * (1 + (this.currentSector-1)*0.15);
            const startX = 50 + Math.random() * (GAME_WIDTH - 100);
            this.entities.push({ 
                type: 'mob', startX: startX, x: startX, y: -50, hp: hp, maxHp: hp, d: d, c: COLORS[d % COLORS.length], scale: 1.0,
                moveOffset: Math.random() * Math.PI * 2, moveSpeed: 0.01 + Math.random() * 0.02, moveAmp: 25 + Math.random() * 40
            });
        }
        else if(r < 0.78 && this.currentSector >= 2) {
            const startX = 50 + Math.random() * (GAME_WIDTH - 100);
            this.entities.push({ type: 'trash', startX: startX, x: startX, y: -50, hp: 10, maxHp: 10, d: 9, c: '#00f2ff', scale: 1.2, moveOffset: Math.random() * Math.PI * 2, moveSpeed: 0.01, moveAmp: 40 });
        }
        else if(r < 0.82 && this.currentSector >= 3) {
            this.entities.push({ type: 'asteroid', x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50, hp: 300, maxHp: 300, d: 6, c: '#444', scale: 2.2 });
        }
        else if(r < 0.92) {
            if(Math.random() > 0.4 && this.entities.filter(e => e.type === 'crate_tech').length === 0) {
                const techs = [{ name: 'PULSE', color: '#00f2ff' }, { name: 'BURST', color: '#ffcc00' }, { name: 'PLASMA', color: '#bc13fe' }, { name: 'EMP', color: '#39ff14' }];
                const t = techs[Math.floor(Math.random() * techs.length)];
                this.entities.push({ type: 'crate_tech', tech: t.name, color: t.color, x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50 });
            } else {
                this.entities.push({ type: 'crate_credit', amt: 300 + Math.floor(Math.random() * 700), x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50 });
            }
        }
    }

    spawnMiniboss() {
        this.eliteActive = true;
        const hp = 2200 * this.currentSector * (1 + (this.squad.length * 0.1));
        this.entities.push({ 
            type: 'elite', x: GAME_WIDTH / 2, y: -80, hp: hp, maxHp: hp, 
            d: 5, c: '#ffcc00', scale: 2.0, 
            moveOffset: 0, moveSpeed: 0.01, moveAmp: 80,
            arrivalY: 120, invuln: 0
        });
        document.getElementById('boss-title').innerText = "ELITE GUARD DETECTED";
        document.getElementById('boss-ui').style.display = 'block';
    }

    triggerBoss() {
        this.bossActive = true;
        const hp = 8000 * this.currentSector * (1 + (this.squad.length * 0.15));
        this.entities.push({ type: 'boss', x: GAME_WIDTH / 2, y: -200, hp: hp, maxHp: hp, d: 11, c: '#ff3131', scale: 3.5, phase: 0, invuln: 0 });
        document.getElementById('boss-title').innerText = "SECTOR COMMANDER";
        document.getElementById('boss-ui').style.display = 'block';
    }

    spawnGate(isForcedGreen = false) {
        const type = isForcedGreen ? 'green' : (Math.random() > 0.5 ? 'red' : 'green');
        const gateWidth = GAME_WIDTH * 0.45; 
        const randomX = (gateWidth / 2 + 20) + Math.random() * (GAME_WIDTH - gateWidth - 40);
        if (type === 'red') {
            const hp = 200 * this.currentSector;
            this.entities.push({ type: 'gate', gateType: 'red', x: randomX, y: -120, hp: hp, maxHp: hp, w: gateWidth });
        } else {
            this.entities.push({ type: 'gate', gateType: 'green', x: randomX, y: -120, charge: 0, maxCharge: 120, rewardMax: 4, w: gateWidth });
        }
    }

    fireWeapon() {
        let rate = Math.max(2, 8 - this.upgrades.speed);
        if(this.tech === 'PULSE') rate = Math.max(1, Math.floor(rate * 0.5));
        if(this.frame % rate === 0) {
            Sound.playWeapon(this.tech || 'STANDARD');
            this.squad.forEach(u => {
                if(this.tech === 'BURST') {
                    [-2, 0, 2].forEach(vx => this.bullets.push({ x: u.x, y: u.y - 10, vx: vx, vy: -12, type: this.tech }));
                } else if(this.tech === 'PULSE') {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -18, type: this.tech });
                } else if(this.tech === 'EMP') {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -10, type: this.tech });
                } else {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -15, type: this.tech });
                }
            });
        }
    }

    update() {
        const sectorBonus = (this.currentSector - 1) * 0.15;
        const timeBonus = (this.frame / 5000) * 0.2; 
        this.speedScale = 1.3 + sectorBonus + timeBonus;

        this.stars.forEach(s => {
            s.y += s.v * (this.active ? this.speedScale : 1);
            if(s.y > GAME_HEIGHT) { s.y = -20; s.x = Math.random() * GAME_WIDTH; }
        });

        this.menuMobs.forEach(m => {
            m.y -= m.v; m.offset += 0.02; m.x = m.startX + Math.sin(m.offset) * 40;
            if(m.y < -100) { m.y = GAME_HEIGHT + 100; m.startX = Math.random() * GAME_WIDTH; }
        });

        if (!this.active) return;

        this.frame++;
        this.playerX += (this.targetX - this.playerX) * 0.25;

        if(this.frame % 110 === 0) this.spawn(); 
        if(this.frame % 550 === 0) this.spawnGate();

        const progress = this.kills / this.targetKills;
        if (progress >= 0.35 && !this.milestonesReached.q1) { this.milestonesReached.q1 = true; this.spawnMiniboss(); }
        if (progress >= 0.75 && !this.milestonesReached.q2) { this.milestonesReached.q2 = true; this.spawnMiniboss(); }

        document.getElementById('prog-fill').style.width = Math.min(100, progress * 100) + '%';
        if(progress >= 1 && !this.bossActive) this.triggerBoss();
        if(this.isFiring) this.fireWeapon();

        this.bullets.forEach(b => {
            b.x += (b.vx || 0); b.y += b.vy;
            this.entities.forEach(e => {
                if(e.invuln > 0) return;
                const currentScale = (e.type === 'asteroid' || e.type === 'elite' || e.type === 'boss') ? (e.scale * (0.8 + 0.2 * (e.hp / e.maxHp))) : (e.scale || 1);
                const box = e.type === 'gate' ? {w: e.w, h: 40} : {w: 40 * currentScale, h: 30 * currentScale};
                
                if(Math.abs(b.x - e.x) < box.w / 2 && Math.abs(b.y - e.y) < box.h / 2) {
                    // GREEN GATE LOGIC: Permeable
                    if (e.type === 'gate' && e.gateType === 'green') {
                        // If fully charged, bullets pass through 100%
                        if (e.charge >= e.maxCharge) {
                            return; 
                        }
                        // If charging, 50% chance to pass through, 50% chance to be absorbed for charge
                        if (Math.random() > 0.5) {
                            e.charge = Math.min(e.maxCharge, e.charge + 2); 
                            b.y = -999; // Bullet absorbed
                        }
                        return; // Let bullet continue if not absorbed
                    }

                    // NORMAL DAMAGE LOGIC
                    let dmg = (this.tech === 'PLASMA') ? 40 : (this.tech === 'PULSE' ? 15 : (this.tech === 'EMP' ? 100 : 10));
                    e.hp -= dmg; b.y = -999;
                    
                    if(['elite', 'boss'].includes(e.type)) {
                        e.invuln = 1; 
                        Sound.playHit();
                        if (navigator.vibrate) navigator.vibrate(10);
                    }
                    
                    if(e.hp <= 0) {
                        Sound.playExplosion();
                        if (navigator.vibrate) navigator.vibrate([60, 30, 60]);
                        if(e.type === 'boss') this.victory();
                        else if(e.type === 'elite') { this.kills += 5; this.creditsThisRun += 1200; this.eliteActive = false; document.getElementById('boss-ui').style.display = 'none'; }
                        else if(e.type === 'trash') { this.kills += 3; this.creditsThisRun += 150; }
                        else if(e.type === 'mob') { this.kills++; this.creditsThisRun += 25; }
                        e.y = 999;
                    }
                }
            });
        });

        this.entities.forEach(e => {
            if(e.invuln > 0) e.invuln--;

            if(e.type === 'boss') {
                if(e.y < 160) e.y += 0.8;
                else { 
                    e.phase += 0.012; 
                    e.x = GAME_WIDTH / 2 + Math.sin(e.phase) * 110; 
                    e.y = 160 + Math.cos(e.phase * 0.7) * 20;
                }
                
                if(this.frame % 130 < 50 && this.frame % 18 === 0) {
                    for(let i = -1; i <= 1; i++) {
                        const angle = (Math.PI / 2) + (i * 0.3);
                        this.enemyBullets.push({x: e.x, y: e.y + 60, vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5});
                    }
                }
                document.getElementById('boss-fill').style.width = (e.hp / e.maxHp * 100) + '%';
            } else if(e.type === 'elite') {
                if(e.y < e.arrivalY) e.y += 1.2;
                else { 
                    e.moveOffset += e.moveSpeed; 
                    e.x = (GAME_WIDTH/2) + Math.sin(e.moveOffset) * e.moveAmp; 
                }
                if(this.frame % 110 === 0) {
                    [-1.2, 1.2].forEach(vx => this.enemyBullets.push({x: e.x, y: e.y + 20, vx: vx, vy: 4.5}));
                }
                document.getElementById('boss-fill').style.width = (e.hp / e.maxHp * 100) + '%';
            } else if(e.type === 'gate') {
                e.y += this.speedScale * 1.1;
            } else if(e.type === 'mob' || e.type === 'trash') {
                e.y += this.speedScale; e.moveOffset += e.moveSpeed; e.x = e.startX + Math.sin(e.moveOffset) * e.moveAmp;
            } else { e.y += this.speedScale; }

            const currentScale = (e.type === 'asteroid' || e.type === 'elite' || e.type === 'boss') ? (e.scale * (0.8 + 0.2 * (e.hp / e.maxHp))) : (e.scale || 1);
            const hitW = e.type === 'gate' ? e.w / 2 : 18 * currentScale;
            const hitH = e.type === 'gate' ? 30 : 25 * currentScale;
            if(Math.abs(e.y - (GAME_HEIGHT - 100)) < hitH && Math.abs(e.x - this.playerX) < hitW) { this.handleCollision(e); }
        });

        this.enemyBullets.forEach(eb => {
            eb.x += (eb.vx || 0); eb.y += (eb.vy || 0);
            if(Math.abs(eb.x - this.playerX) < 18 && Math.abs(eb.y - (GAME_HEIGHT - 100)) < 18) { this.damageSquad(); eb.y = 999; }
        });

        if(this.techTimer > 0) {
            this.techTimer--;
            document.getElementById('tech-indicator').style.display = 'block';
            document.getElementById('tech-name').innerText = this.tech + " (" + Math.ceil(this.techTimer/60) + "s)";
            if(this.techTimer === 0) { this.tech = null; document.getElementById('tech-indicator').style.display = 'none'; }
        }

        this.squad.forEach(u => {
            u.angle += u.rot;
            u.x = this.playerX + Math.cos(u.angle) * u.dist;
            u.y = (GAME_HEIGHT - 100) + Math.sin(u.angle) * u.dist * 0.5;
        });

        this.bullets = this.bullets.filter(b => b.y > -20);
        this.enemyBullets = this.enemyBullets.filter(eb => eb.y < GAME_HEIGHT + 20 && eb.x > -50 && eb.x < GAME_WIDTH + 50);
        this.entities = this.entities.filter(e => e.y < GAME_HEIGHT + 120);
        document.getElementById('squad-display').innerText = this.squad.length;
        document.getElementById('credit-display').innerText = Math.floor(this.creditsThisRun);
    }

    handleCollision(e) {
        if(e.type === 'gate') {
            if(e.gateType === 'red') {
                const penalty = Math.ceil(this.squad.length * 0.25);
                if (navigator.vibrate) navigator.vibrate(150);
                for(let i = 0; i < penalty; i++) this.damageSquad();
            } else {
                const unitsToAdd = Math.floor((e.charge / e.maxCharge) * e.rewardMax);
                for(let i = 0; i < unitsToAdd; i++) if(this.squad.length < this.MAX_SQUAD) this.addUnit('player');
            }
            e.y = 999;
        } else if(e.type === 'crate_credit') { this.creditsThisRun += e.amt; e.y = 999; }
        else if(e.type === 'crate_tech') { this.tech = e.tech; this.techTimer = 600; e.y = 999; }
        else if(['mob', 'trash', 'asteroid', 'elite', 'boss'].includes(e.type)) { this.damageSquad(); if(!['elite', 'boss', 'asteroid'].includes(e.type)) e.y = 999; }
    }

    damageSquad() {
        if(this.squad.length === 0) return;
        const idx = Math.floor(Math.random() * this.squad.length);
        this.squad[idx].hp--;
        if (navigator.vibrate) navigator.vibrate(30);
        if(this.squad[idx].hp <= 0) {
            Sound.playExplosion();
            const u = this.squad.splice(idx, 1)[0];
            if(u.type === 'perma') this.upgrades.perma--;
            if(u.type === 'temp') this.upgrades.temp--;
            if(this.squad.length === 0) this.gameOver();
        }
    }

    drawPixelObj(dIdx, color, x, y, scale, isInvuln = false) {
        if(isInvuln && this.frame % 4 < 2) return; 
        const design = DESIGNS[dIdx];
        const p = 5 * scale;
        const w = design[0].length * p;
        const h = design.length * p;
        ctx.save();
        ctx.translate(Math.floor(x - w / 2), Math.floor(y - h / 2));
        ctx.shadowBlur = 10 * scale; ctx.shadowColor = color; ctx.fillStyle = color;
        design.forEach((row, r) => { [...row].forEach((char, c) => { if(char === 'X') ctx.fillRect(c * p, r * p, p, p); }); });
        ctx.shadowBlur = 0; ctx.fillStyle = '#fff';
        design.forEach((row, r) => { [...row].forEach((char, c) => { if(char === 'X') ctx.fillRect(c * p + 1, r * p + 1, p - 2, p - 2); }); });
        ctx.restore();
    }

    draw() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        this.stars.forEach(s => { ctx.fillStyle = `rgba(255,255,255,${0.3 * s.z})`; ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.z, s.z); });

        if(!this.active) { this.menuMobs.forEach(m => this.drawPixelObj(m.d, m.c, m.x, m.y, m.scale)); } 
        else {
            this.entities.forEach(e => {
                if(e.type === 'gate') {
                    const isGreen = e.gateType === 'green';
                    const color = isGreen ? '#39ff14' : '#ff3131';
                    
                    // Pulsing effect for green gates that are permeable
                    const alpha = (isGreen && e.charge < e.maxCharge) ? (0.6 + Math.sin(this.frame * 0.2) * 0.2) : 1.0;
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.shadowBlur = 15; ctx.shadowColor = color; ctx.fillStyle = color;
                    ctx.fillRect(e.x - e.w / 2 - 5, e.y - 20, 10, 40); ctx.fillRect(e.x + e.w / 2 - 5, e.y - 20, 10, 40);
                    ctx.shadowBlur = 0; ctx.globalAlpha = isGreen ? 0.1 : 0.25; ctx.fillRect(e.x - e.w / 2, e.y - 15, e.w, 30);
                    
                    ctx.restore();
                    ctx.fillStyle = '#222'; ctx.fillRect(e.x - 40, e.y - 32, 80, 4);
                    if (isGreen) {
                        ctx.fillStyle = color; ctx.fillRect(e.x - 40, e.y - 32, 80 * (e.charge / e.maxCharge), 4);
                        ctx.fillStyle = '#fff'; ctx.font = '900 12px Orbitron'; ctx.textAlign = 'center'; 
                        const msg = e.charge >= e.maxCharge ? "MAX CHARGE" : `+${Math.floor((e.charge/e.maxCharge)*5)} SQUAD`;
                        ctx.fillText(msg, e.x, e.y + 5);
                    } else {
                        ctx.fillStyle = color; ctx.fillRect(e.x - 40, e.y - 32, 80 * (e.hp / e.maxHp), 4);
                        ctx.fillStyle = '#fff'; ctx.font = '900 12px Orbitron'; ctx.textAlign = 'center'; ctx.fillText('BARRIER', e.x, e.y + 5);
                    }
                } else if(e.type === 'crate_tech' || e.type === 'crate_credit') {
                    const col = e.type === 'crate_tech' ? e.color : '#ffcc00';
                    ctx.fillStyle = col; ctx.shadowBlur = 15; ctx.shadowColor = col;
                    ctx.fillRect(e.x - 25, e.y - 20, 50, 40); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
                    ctx.fillText(e.type === 'crate_tech' ? e.tech : '$', e.x, e.y + 5);
                } else {
                    let s = e.scale * (['asteroid', 'elite', 'boss'].includes(e.type) ? (0.8 + 0.2 * (e.hp / e.maxHp)) : 1);
                    this.drawPixelObj(e.d, e.c, e.x, e.y, s, e.invuln > 0);
                    
                    if (e.hp < e.maxHp && !['boss', 'elite'].includes(e.type)) {
                        ctx.fillStyle = '#300'; ctx.fillRect(e.x - 15, e.y + 15, 30, 3);
                        ctx.fillStyle = '#f33'; ctx.fillRect(e.x - 15, e.y + 15, 30 * (e.hp/e.maxHp), 3);
                    }
                }
            });
            this.bullets.forEach(b => {
                ctx.shadowBlur = 10; ctx.fillStyle = b.type === 'PLASMA' ? '#bc13fe' : (b.type === 'PULSE' ? '#00f2ff' : (b.type === 'BURST' ? '#ffcc00' : (b.type === 'EMP' ? '#39ff14' : '#fff')));
                ctx.shadowColor = ctx.fillStyle; ctx.fillRect(b.x - 2, b.y, 4, 15); ctx.shadowBlur = 0;
            });
            this.enemyBullets.forEach(eb => {
                ctx.fillStyle = '#ff3131'; ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
                ctx.beginPath(); ctx.arc(Math.floor(eb.x), Math.floor(eb.y), 6, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            });
            this.squad.forEach(u => this.drawPixelObj(0, u.color, u.x, u.y, 0.7));
        }
    }

    gameOver() { 
        this.active = false; 
        this.totalCredits += this.creditsThisRun; 
        Sound.stopAll();
        this.updateHUDVisibility(false); 
        document.getElementById('death-overlay').style.display = 'flex'; 
    }
    victory() { 
        this.active = false; 
        this.totalCredits += this.creditsThisRun + 2000; 
        Sound.stopAll();
        this.updateHUDVisibility(false); 
        document.getElementById('victory-overlay').style.display = 'flex'; 
    }
    showMenu() { 
        this.active = false; 
        Sound.stopAll();
        this.updateHUDVisibility(false); 
        document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none'); 
        document.getElementById('menu-overlay').style.display = 'flex'; 
    }
    openMarket() {
        this.updateHUDVisibility(false); document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none'); document.getElementById('market-overlay').style.display = 'flex';
        document.getElementById('market-credits').innerText = Math.floor(this.totalCredits);
        const list = [
            { id: 'hull', n: `STRUCTURAL HULL (+${this.upgrades.hull})`, p: 800 },
            { id: 'speed', n: `PLASMA FIRE RATE (+${this.upgrades.speed})`, p: 1200 },
            { id: 'perma', n: `PERMANENT MERCENARY`, p: 4000 },
            { id: 'temp', n: `SECTOR MERCENARY (TEMP)`, p: 600 }
        ];
        document.getElementById('market-items').innerHTML = list.map(i => `<button class="btn" ${this.totalCredits < i.p ? 'disabled' : ''} onclick="game.buyUp('${i.id}', ${i.p})">${i.n} - ${i.p} CR</button>`).join('');
    }
    buyUp(id, p) { if(this.totalCredits >= p){ this.totalCredits -= p; this.upgrades[id]++; this.openMarket(); } }
    closeMarket() { this.showMenu(); }
    loop() { this.update(); this.draw(); requestAnimationFrame(() => this.loop()); }
}
const game = new Game();
</script>
</body>
</html>
