<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Road: Fleet Command</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff0077;
            --neon-purple: #bc13fe;
            --neon-red: #ff3131;
            --neon-yellow: #ffcc00;
            --neon-green: #39ff14;
        }
        body { 
            margin: 0; background: #000; color: #fff; 
            font-family: 'Orbitron', sans-serif; overflow: hidden; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; touch-action: none;
        }
        #game-container {
            position: relative; 
            background: #000; width: 100%; height: 100%;
            max-width: 450px; max-height: 800px; border: 2px solid #222;
            display: flex; flex-direction: column; overflow: hidden;
        }
        canvas { display: block; width: 100%; flex: 1; background: #000; image-rendering: pixelated; }
        
        #control-deck {
            height: 120px; background: linear-gradient(to bottom, #151515, #000);
            border-top: 3px solid var(--neon-blue); position: relative;
            cursor: crosshair; z-index: 30;
        }
        #deck-glow {
            position: absolute; top: 0; height: 6px; width: 120px;
            background: var(--neon-blue); box-shadow: 0 0 30px var(--neon-blue);
            pointer-events: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 20px; box-sizing: border-box; pointer-events: none;
            display: none; justify-content: space-between; z-index: 50;
        }
        .stat-box { 
            background: rgba(0,0,0,0.8); padding: 10px 15px; 
            border-left: 3px solid var(--neon-blue); border-top: 1px solid #333;
        }
        .stat-label { font-size: 10px; color: var(--neon-blue); display: block; text-transform: uppercase; letter-spacing: 2px; }
        .stat-value { font-size: 18px; font-weight: 900; text-shadow: 0 0 10px var(--neon-blue); }
        
        #progression-container {
            position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%);
            width: 85%; pointer-events: none; z-index: 40; display: none;
        }
        .prog-bar-bg { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; border: 1px solid #333; }
        .prog-bar-fill { height: 100%; background: linear-gradient(90deg, var(--neon-blue), #fff); width: 0%; transition: width 0.3s; }

        #tech-indicator {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            color: var(--neon-purple); font-weight: 900; font-size: 12px;
            text-shadow: 0 0 10px var(--neon-purple); display: none;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            z-index: 100; padding: 30px; box-sizing: border-box;
        }
        
        h2 { color: #fff; font-size: 48px; margin: 0; text-shadow: 0 0 30px var(--neon-blue); font-weight: 900; letter-spacing: -2px; }
        p { letter-spacing: 4px; font-weight: 700; color: var(--neon-blue); margin-top: 10px; font-size: 14px; }
        
        .btn {
            padding: 20px 30px; font-size: 16px; font-family: 'Orbitron', sans-serif;
            font-weight: 900; cursor: pointer; border: 2px solid var(--neon-blue);
            background: rgba(0,0,0,0.9); color: var(--neon-blue); width: 100%; text-transform: uppercase;
            margin-top: 15px; transition: all 0.2s; outline: none;
        }
        .btn:hover:not(:disabled) { background: var(--neon-blue); color: #000; box-shadow: 0 0 30px var(--neon-blue); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: #444; color: #444; }

        #boss-ui {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 80%; display: none; z-index: 60;
        }
        .hp-bar-outer { width: 100%; height: 12px; background: #200; border: 2px solid #fff; border-radius: 6px; overflow: hidden; }
        .hp-bar-inner { height: 100%; background: var(--neon-red); width: 100%; }
        .hp-label { color: #fff; font-size: 10px; font-weight: 900; text-align: center; display: block; margin-bottom: 4px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div style="display: flex; gap: 15px;">
            <div class="stat-box">
                <span class="stat-label">SQUAD</span>
                <span id="squad-display" class="stat-value">1</span>
            </div>
            <div class="stat-box" style="border-color: var(--neon-purple)">
                <span class="stat-label">SECTOR</span>
                <span id="sector-display" class="stat-value">1</span>
            </div>
        </div>
        <div class="stat-box" style="border-color: var(--neon-green)">
            <span class="stat-label">CREDITS</span>
            <span id="credit-display" class="stat-value">0</span>
        </div>
    </div>

    <div id="tech-indicator">ACTIVE: <span id="tech-name">NONE</span></div>

    <div id="progression-container">
        <div class="prog-bar-bg"><div id="prog-fill" class="prog-bar-fill"></div></div>
    </div>

    <div id="boss-ui">
        <span id="boss-title" class="hp-label">BOSS DETECTED</span>
        <div class="hp-bar-outer"><div id="boss-fill" class="hp-bar-inner"></div></div>
    </div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h2>NEON ROAD</h2>
        <p>RECON UNIT ALPHA</p>
        <button class="btn" onclick="game.startCampaign()">Initialize Run</button>
        <button class="btn" style="border-color: var(--neon-purple); color: var(--neon-purple);" onclick="game.openMarket()">Black Market</button>
    </div>

    <div id="market-overlay" class="overlay">
        <h2 style="font-size: 28px;">BLACK MARKET</h2>
        <p>AVAILABLE CREDITS: <span id="market-credits">0</span></p>
        <div id="market-items" style="width: 100%; max-height: 450px; overflow-y: auto; margin: 20px 0;"></div>
        <button class="btn" onclick="game.closeMarket()">Return to Menu</button>
    </div>

    <div id="death-overlay" class="overlay">
        <h2 style="color: var(--neon-red)">SQUAD LOST</h2>
        <p id="death-stats">MISSION FAILURE</p>
        <button class="btn" onclick="game.startCampaign()">New Run</button>
        <button class="btn" onclick="game.showMenu()">Main Menu</button>
    </div>

    <div id="victory-overlay" class="overlay">
        <h2 style="color: var(--neon-green)">SECTOR CLEAR</h2>
        <button class="btn" onclick="game.nextSector()">Advance Sector</button>
        <button class="btn" style="border-color: var(--neon-purple); color: var(--neon-purple);" onclick="game.openMarket()">Visit Market</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="control-deck"><div id="deck-glow"></div></div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const deck = document.getElementById('control-deck');
const glow = document.getElementById('deck-glow');

const GAME_WIDTH = 450;
const GAME_HEIGHT = 700;
canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

ctx.imageSmoothingEnabled = false;

const DESIGNS = [
    ["  X  X  ", "   XX   ", "  XXXX  ", " XXXXXX ", "XX XX XX", "  XXXX  "],
    ["  X     X  ", "   X   X   ", "  XXXXXXX  ", " XX XXX XX ", "XXXXXXXXXXX", "X XXXXXXX X", "X X     X X", "   XX XX   "],
    ["    XX    ", "   XXXX   ", "  XXXXXX  ", " XX XX XX ", " XXXXXXXX ", "  X XX X  ", " X      X ", "  X    X  "],
    ["  XX  XX  ", " XXXXXXXXX", "XXXXXXXXXX", "XX XXXX XX", "XXXXXXXXXX", "  X XX X  "],
    ["   X  X   ", "  XXXXXX  ", " XX XX XX ", "XXXXXXXXXX", " X      X ", "  X    X  "],
    ["  XXXXXX  ", " XXXXXXXX ", "XXXXXXXXXX", "XXX XX XXX", "XXXXXXXXXX", " X XXXX X ", "  X    X  "],
    ["    XX    ", "  XXXXXX  ", "XXXXXXXXXX", "  XXXXXX  ", "   XXXX   ", "    XX    "],
    [" X      X ", "  X    X  ", "  XXXXXX  ", "XXXXXXXXXX", "XX XXXX XX", "  XXXXXX  ", "   X  X   "],
    [" XXXXXXXX ", "XXXXXXXXXX", "XX  XX  XX", "XXXXXXXXXX", "XXXXXXXXXX", " XX    XX " ],
    ["  XXXXXX  ", " X      X ", " X  XX  X ", " XXXXXXXX ", " X X  X X ", " X      X "],
    [" XX    XX ", "  XX  XX  ", " XXXXXXXX ", "XX XX XX  ", "XXXXXXXXXX", "X  XXXX  X"],
    ["   XXXX   ", "  XXXXXX  ", " XXXXXXXX ", "XX XX XX XX", "XXXXXXXXXXX", "XXX XX XXX", " X      X "]
];

const COLORS = ['#bc13fe', '#00f2ff', '#ff0077', '#ffcc00', '#39ff14', '#ff3131'];

class Game {
    constructor() {
        this.totalCredits = 0;
        this.upgrades = { hull: 0, speed: 0, perma: 0, temp: 0, color: '#00f2ff' };
        this.currentSector = 1;
        this.persistentSquad = 1;
        this.MAX_SQUAD = 15;

        this.stars = Array.from({length: 80}, () => ({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            v: 0.5 + Math.random() * 1.5,
            z: Math.random() * 2 + 1
        }));

        this.menuMobs = Array.from({length: 12}, () => ({
            startX: Math.random() * GAME_WIDTH,
            x: 0,
            y: Math.random() * GAME_HEIGHT,
            v: 0.8 + Math.random() * 0.8,
            offset: Math.random() * Math.PI * 2,
            d: Math.floor(Math.random() * 12),
            c: COLORS[Math.floor(Math.random() * COLORS.length)],
            scale: 1.5
        }));

        this.setupInput();
        this.reset();
        this.showMenu();
        this.loop();
    }

    reset() {
        this.active = false;
        this.frame = 0;
        this.kills = 0;
        this.targetKills = 40 + (this.currentSector * 20);
        this.creditsThisRun = 0;
        this.playerX = GAME_WIDTH / 2;
        this.targetX = GAME_WIDTH / 2;
        this.isFiring = false;
        this.bossActive = false;
        this.entities = [];
        this.bullets = [];
        this.enemyBullets = [];
        this.squad = [];
        this.tech = null;
        this.techTimer = 0;
        this.initSquad();
    }

    updateHUDVisibility(show) {
        const display = show ? 'flex' : 'none';
        document.getElementById('ui-layer').style.display = display;
        document.getElementById('progression-container').style.display = display;
        if(!show) {
            document.getElementById('boss-ui').style.display = 'none';
            document.getElementById('tech-indicator').style.display = 'none';
        }
    }

    initSquad() {
        this.squad = [];
        const baseCount = Math.min(this.MAX_SQUAD, this.persistentSquad);
        for(let i=0; i < baseCount; i++) this.addUnit('player');
        
        for(let i=0; i < this.upgrades.perma; i++) this.addUnit('perma');
        for(let i=0; i < this.upgrades.temp; i++) this.addUnit('temp');
    }

    addUnit(type) {
        if(this.squad.length >= this.MAX_SQUAD) return;

        let color = this.upgrades.color;
        if(type === 'perma') color = '#bc13fe';
        if(type === 'temp') color = '#ffcc00';
        
        this.squad.push({
            type, color,
            angle: Math.random() * Math.PI * 2,
            dist: 15 + Math.random() * 20,
            rot: 0.03 + Math.random() * 0.02,
            hp: 1 + this.upgrades.hull,
            x: 0, y: 0
        });
    }

    setupInput() {
        const handleInteraction = (clientX) => {
            const rect = canvas.getBoundingClientRect();
            const relX = (clientX - rect.left) / rect.width;
            this.targetX = Math.max(30, Math.min(GAME_WIDTH - 30, relX * GAME_WIDTH));
            const deckWidth = deck.offsetWidth;
            glow.style.left = (relX * deckWidth - 60) + "px";
        };

        window.addEventListener('touchstart', (e) => {
            if (!this.active) return;
            this.isFiring = true;
            handleInteraction(e.touches[0].clientX);
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (!this.active) return;
            e.preventDefault();
            handleInteraction(e.touches[0].clientX);
        }, { passive: false });

        window.addEventListener('touchend', () => {
            this.isFiring = false;
        });

        window.addEventListener('mousedown', (e) => {
            if (!this.active) return;
            this.isFiring = true;
            handleInteraction(e.clientX);
        });

        window.addEventListener('mousemove', (e) => {
            if (!this.active || !this.isFiring) return;
            handleInteraction(e.clientX);
        });

        window.addEventListener('mouseup', () => {
            this.isFiring = false;
        });
    }

    startCampaign() { this.currentSector = 1; this.persistentSquad = 1; this.upgrades.temp = 0; this.start(); }
    nextSector() { this.currentSector++; this.persistentSquad = this.squad.filter(u=>u.type==='player').length; this.start(); }
    
    start() { 
        this.reset(); 
        this.active = true; 
        this.updateHUDVisibility(true);
        document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none');
        document.getElementById('sector-display').innerText = this.currentSector;
    }

    spawn() {
        if(this.bossActive) return;
        const r = Math.random();
        
        const activeTechCrates = this.entities.filter(e => e.type === 'crate_tech').length;

        // Less clutter: Increased mob chance, decreased small loot chance
        if(r < 0.65) {
            const d = Math.floor(Math.random() * 12);
            const hp = (20 + d*8) * (1 + (this.currentSector-1)*0.25);
            const startX = 50 + Math.random() * (GAME_WIDTH - 100);
            this.entities.push({ 
                type: 'mob', startX: startX, x: startX, y: -50, hp: hp, maxHp: hp, d: d, c: COLORS[d % COLORS.length], scale: 1.0,
                moveOffset: Math.random() * Math.PI * 2, moveSpeed: 0.01 + Math.random() * 0.02, moveAmp: 25 + Math.random() * 40
            });
        }
        else if(r < 0.78 && this.currentSector >= 2) {
            // Mini Boss / Trash: Made larger and distinct
            const startX = 50 + Math.random() * (GAME_WIDTH - 100);
            this.entities.push({ 
                type: 'trash', startX: startX, x: startX, y: -50, hp: 15, maxHp: 15, d: 9, c: '#00f2ff', scale: 1.2,
                moveOffset: Math.random() * Math.PI * 2, moveSpeed: 0.01, moveAmp: 40
            });
        }
        else if(r < 0.82 && this.currentSector >= 3) {
            this.entities.push({ type: 'asteroid', x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50, hp: 400, maxHp: 400, d: 6, c: '#444', scale: 2.2 });
        }
        else if(r < 0.92) {
            if(Math.random() > 0.4 && activeTechCrates === 0) {
                const techs = [
                    { name: 'PULSE', color: '#00f2ff' },
                    { name: 'BURST', color: '#ffcc00' },
                    { name: 'PLASMA', color: '#bc13fe' },
                    { name: 'EMP', color: '#39ff14' }
                ];
                const t = techs[Math.floor(Math.random() * techs.length)];
                this.entities.push({ type: 'crate_tech', tech: t.name, color: t.color, x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50 });
            } else {
                // Larger credit amount, fewer drops
                this.entities.push({ type: 'crate_credit', amt: 300 + Math.floor(Math.random() * 700), x: 50 + Math.random() * (GAME_WIDTH - 100), y: -50 });
            }
        }
    }

    spawnGate(isForcedGreen = false) {
        const type = isForcedGreen ? 'green' : (Math.random() > 0.5 ? 'red' : 'green');
        const gateWidth = GAME_WIDTH * 0.5; 
        
        const minX = gateWidth / 2 + 20;
        const maxX = GAME_WIDTH - (gateWidth / 2) - 20;
        const randomX = minX + Math.random() * (maxX - minX);
        
        if (type === 'red') {
            const hp = 200 * this.currentSector;
            this.entities.push({ 
                type: 'gate', gateType: 'red', x: randomX, y: -120, 
                hp: hp, maxHp: hp, w: gateWidth 
            });
        } else {
            this.entities.push({ 
                type: 'gate', gateType: 'green', x: randomX, y: -120, 
                charge: 0, maxCharge: 150, 
                rewardMax: 6, 
                w: gateWidth 
            });
        }
    }

    triggerBoss() {
        this.bossActive = true;
        const hp = 5000 * this.currentSector;
        // Moved starting Y lower so it doesn't overlap health bar
        this.entities.push({ type: 'boss', x: GAME_WIDTH / 2, y: -200, hp: hp, maxHp: hp, d: 11, c: '#ff3131', scale: 4.0, phase: 0 });
        document.getElementById('boss-ui').style.display = 'block';
    }

    fireWeapon() {
        let rate = Math.max(2, 8 - this.upgrades.speed);
        if(this.tech === 'PULSE') rate = Math.max(1, Math.floor(rate * 0.4));
        
        if(this.frame % rate === 0) {
            this.squad.forEach(u => {
                if(this.tech === 'BURST') {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: -2, vy: -12, type: this.tech });
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -15, type: this.tech });
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 2, vy: -12, type: this.tech });
                } else if(this.tech === 'PULSE') {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -18, type: this.tech });
                } else if(this.tech === 'EMP') {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -10, type: this.tech });
                } else {
                    this.bullets.push({ x: u.x, y: u.y - 10, vx: 0, vy: -15, type: this.tech });
                }
            });
        }
    }

    update() {
        this.stars.forEach(s => {
            s.y += s.v;
            if(s.y > GAME_HEIGHT) { s.y = -20; s.x = Math.random() * GAME_WIDTH; }
        });

        this.menuMobs.forEach(m => {
            m.y -= m.v;
            m.offset += 0.02;
            m.x = m.startX + Math.sin(m.offset) * 40;
            if(m.y < -100) { m.y = GAME_HEIGHT + 100; m.startX = Math.random() * GAME_WIDTH; }
        });

        if (!this.active) return;

        this.frame++;
        this.playerX += (this.targetX - this.playerX) * 0.25;

        if(this.frame % 90 === 0) this.spawn(); 
        
        // Forced Green Gate at 4 seconds (240 frames)
        if(this.frame === 240) {
            this.spawnGate(true);
        } else if(this.frame % 540 === 0) {
            this.spawnGate();
        }

        const progress = this.kills / this.targetKills;
        document.getElementById('prog-fill').style.width = Math.min(100, progress * 100) + '%';
        if(progress >= 1 && !this.bossActive) this.triggerBoss();

        if(this.isFiring) this.fireWeapon();

        this.bullets.forEach(b => {
            b.x += (b.vx || 0);
            b.y += b.vy;
            this.entities.forEach(e => {
                const currentScale = e.type === 'asteroid' ? (e.scale * (0.4 + 0.6 * (e.hp / e.maxHp))) : (e.scale || 1);
                const box = e.type === 'gate' ? {w: e.w, h: 40} : {w: 40 * currentScale, h: 30 * currentScale};
                
                if(Math.abs(b.x - e.x) < box.w / 2 && Math.abs(b.y - e.y) < box.h / 2) {
                    if (e.type === 'gate' && e.gateType === 'green') {
                        e.charge = Math.min(e.maxCharge, e.charge + 1);
                        b.y = -999;
                        return;
                    }

                    let dmg = 5;
                    if(b.type === 'PLASMA') dmg = 25;
                    if(b.type === 'PULSE') dmg = 8;
                    if(b.type === 'EMP') dmg = 50;
                    
                    e.hp -= dmg; b.y = -999;
                    if(e.hp <= 0) {
                        if(e.type === 'boss') this.victory();
                        else if(e.type === 'trash') { this.kills += 3; this.creditsThisRun += 150; }
                        else if(e.type === 'mob') { this.kills++; this.creditsThisRun += 20; }
                        e.y = 999;
                    }
                }
            });
        });

        this.entities.forEach(e => {
            if(e.type === 'boss') {
                // Boss stays lower (220y) so it's clearly below health bar
                if(e.y < 220) e.y += 1;
                else { e.phase += 0.02; e.x = GAME_WIDTH / 2 + Math.sin(e.phase) * 100; }
                if(this.frame % 50 === 0) this.enemyBullets.push({x: e.x, y: e.y + 50, vy: 5});
                document.getElementById('boss-fill').style.width = (e.hp / e.maxHp * 100) + '%';
            } else if(e.type === 'gate') {
                e.y += 1.6;
            } else if(e.type === 'mob' || e.type === 'trash') {
                e.y += 1.4; 
                e.moveOffset += e.moveSpeed; 
                e.x = e.startX + Math.sin(e.moveOffset) * e.moveAmp;
            } else {
                e.y += 1.4;
            }

            const currentScale = e.type === 'asteroid' ? (e.scale * (0.4 + 0.6 * (e.hp / e.maxHp))) : (e.scale || 1);
            const hitW = e.type === 'gate' ? e.w / 2 : 18 * currentScale;
            const hitH = e.type === 'gate' ? 30 : 25 * currentScale;
            
            if(Math.abs(e.y - (GAME_HEIGHT - 100)) < hitH && Math.abs(e.x - this.playerX) < hitW) {
                this.handleCollision(e);
            }
        });

        this.enemyBullets.forEach(eb => {
            eb.y += eb.vy;
            if(Math.abs(eb.x - this.playerX) < 20 && Math.abs(eb.y - (GAME_HEIGHT - 100)) < 20) {
                this.damageSquad(); eb.y = 999;
            }
        });

        if(this.techTimer > 0) {
            this.techTimer--;
            document.getElementById('tech-indicator').style.display = 'block';
            document.getElementById('tech-name').innerText = this.tech + " (" + Math.ceil(this.techTimer/60) + "s)";
            if(this.techTimer === 0) {
                this.tech = null;
                document.getElementById('tech-indicator').style.display = 'none';
            }
        }

        this.squad.forEach(u => {
            u.angle += u.rot;
            const orbitX = Math.cos(u.angle) * u.dist;
            const orbitY = Math.sin(u.angle) * u.dist * 0.5;
            u.x = this.playerX + orbitX;
            u.y = (GAME_HEIGHT - 100) + orbitY;
        });

        this.bullets = this.bullets.filter(b => b.y > -20);
        this.enemyBullets = this.enemyBullets.filter(eb => eb.y < GAME_HEIGHT + 20);
        this.entities = this.entities.filter(e => e.y < GAME_HEIGHT + 100);

        document.getElementById('squad-display').innerText = this.squad.length;
        document.getElementById('credit-display').innerText = Math.floor(this.creditsThisRun);
    }

    handleCollision(e) {
        if(e.type === 'gate') {
            if(e.gateType === 'red') {
                const ratio = Math.max(0.2, e.hp / e.maxHp);
                const penalty = Math.ceil(this.squad.length * ratio);
                for(let i = 0; i < penalty; i++) this.damageSquad();
            } else {
                const chargePercent = e.charge / e.maxCharge;
                const floatShips = chargePercent * e.rewardMax;
                const unitsToAdd = Math.floor(floatShips);
                
                for(let i = 0; i < unitsToAdd; i++) {
                    if(this.squad.length < this.MAX_SQUAD) this.addUnit('player');
                }
            }
            e.y = 999;
        } else if(e.type === 'crate_credit') {
            this.creditsThisRun += e.amt; e.y = 999;
        } else if(e.type === 'crate_tech') {
            this.tech = e.tech; 
            this.techTimer = 600; 
            e.y = 999;
        } else if(['mob', 'trash', 'asteroid'].includes(e.type)) {
            this.damageSquad(); e.y = 999;
        }
    }

    damageSquad() {
        if(this.squad.length === 0) return;
        const idx = Math.floor(Math.random() * this.squad.length);
        this.squad[idx].hp--;
        if(this.squad[idx].hp <= 0) {
            const u = this.squad.splice(idx, 1)[0];
            if(u.type === 'perma') this.upgrades.perma--;
            if(u.type === 'temp') this.upgrades.temp--;
            if(this.squad.length === 0) this.gameOver();
        }
    }

    drawPixelObj(dIdx, color, x, y, scale, isWallpaper = false) {
        const design = DESIGNS[dIdx];
        const p = 5 * scale;
        const w = design[0].length * p;
        const h = design.length * p;
        ctx.save();
        ctx.translate(Math.floor(x - w / 2), Math.floor(y - h / 2));
        
        ctx.shadowBlur = isWallpaper ? 25 : (10 * scale);
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        
        design.forEach((row, r) => {
            [...row].forEach((char, c) => {
                if(char === 'X') ctx.fillRect(c * p, r * p, p, p);
            });
        });
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        design.forEach((row, r) => {
            [...row].forEach((char, c) => {
                if(char === 'X') ctx.fillRect(c * p + 1, r * p + 1, p - 2, p - 2);
            });
        });
        ctx.restore();
    }

    draw() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        this.stars.forEach(s => {
            ctx.fillStyle = `rgba(255,255,255,${0.3 * s.z})`;
            ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.z, s.z);
        });

        if(!this.active) {
            this.menuMobs.forEach(m => { this.drawPixelObj(m.d, m.c, m.x, m.y, m.scale, true); });
        } else {
            this.entities.forEach(e => {
                if(e.type === 'gate') {
                    const isGreen = e.gateType === 'green';
                    const color = isGreen ? '#39ff14' : '#ff3131';
                    const gateHeight = 40; const pillarWidth = 10;
                    
                    ctx.shadowBlur = 15; ctx.shadowColor = color; ctx.fillStyle = color;
                    ctx.fillRect(e.x - e.w / 2 - pillarWidth / 2, e.y - gateHeight / 2, pillarWidth, gateHeight);
                    ctx.fillRect(e.x + e.w / 2 - pillarWidth / 2, e.y - gateHeight / 2, pillarWidth, gateHeight);
                    
                    ctx.shadowBlur = 0; ctx.globalAlpha = 0.15;
                    ctx.fillRect(e.x - e.w / 2, e.y - gateHeight / 2 + 5, e.w, gateHeight - 10);
                    
                    ctx.globalAlpha = 0.3;
                    for(let i = -e.w / 2; i < e.w / 2; i += 40) {
                        const offset = (this.frame % 40);
                        ctx.fillRect(e.x + i + offset - 20, e.y - gateHeight / 2 + 5, 2, gateHeight - 10);
                    }
                    ctx.globalAlpha = 1.0; 
                    
                    ctx.fillStyle = '#222';
                    ctx.fillRect(e.x - 40, e.y - gateHeight / 2 - 12, 80, 4);
                    
                    if (isGreen) {
                        ctx.fillStyle = color; 
                        ctx.fillRect(e.x - 40, e.y - gateHeight / 2 - 12, 80 * (e.charge / e.maxCharge), 4);
                        
                        const potential = Math.floor((e.charge / e.maxCharge) * e.rewardMax);
                        ctx.fillStyle = '#fff'; ctx.font = '900 12px Orbitron'; ctx.textAlign = 'center';
                        ctx.fillText(`CHARGE: +${potential}`, e.x, e.y + 5);
                    } else {
                        ctx.fillStyle = color; 
                        ctx.fillRect(e.x - 40, e.y - gateHeight / 2 - 12, 80 * (e.hp / e.maxHp), 4);
                        ctx.fillStyle = '#fff'; ctx.font = '900 12px Orbitron'; ctx.textAlign = 'center';
                        ctx.fillText('BARRIER', e.x, e.y + 5);
                    }
                } else if(e.type === 'crate_tech') {
                    ctx.fillStyle = e.color || '#bc13fe'; 
                    ctx.shadowBlur = 15; ctx.shadowColor = e.color;
                    ctx.fillRect(e.x - 30, e.y - 20, 60, 40); 
                    ctx.shadowBlur = 0; ctx.strokeStyle = '#fff'; ctx.strokeRect(e.x - 30, e.y - 20, 60, 40);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Orbitron'; ctx.textAlign = 'center';
                    ctx.fillText(e.tech, e.x, e.y + 5);
                } else if(e.type === 'crate_credit') {
                    ctx.fillStyle = '#ffcc00'; ctx.strokeStyle = '#fff';
                    ctx.strokeRect(e.x - 25, e.y - 25, 50, 50); ctx.fillRect(e.x - 25, e.y - 25, 50, 50);
                    ctx.fillStyle = '#000'; ctx.font = 'bold 24px Orbitron'; ctx.textAlign = 'center';
                    ctx.fillText('$', e.x, e.y + 10);
                } else {
                    let s = e.scale;
                    if(e.type === 'asteroid') s *= (0.4 + 0.6 * (e.hp / e.maxHp));
                    this.drawPixelObj(e.d, e.c, e.x, e.y, s);
                    if(e.hp < e.maxHp && e.type !== 'boss') {
                        const barW = 30 * s;
                        ctx.fillStyle = '#222'; ctx.fillRect(e.x - barW / 2, e.y - (25 * s), barW, 4);
                        ctx.fillStyle = (e.hp / e.maxHp > 0.4) ? '#39ff14' : '#ff3131';
                        ctx.fillRect(e.x - barW / 2, e.y - (25 * s), barW * (e.hp / e.maxHp), 4);
                    }
                }
            });

            this.bullets.forEach(b => {
                ctx.shadowBlur = 10;
                if(b.type === 'PLASMA') { ctx.fillStyle = '#bc13fe'; ctx.shadowColor = '#bc13fe'; ctx.fillRect(b.x - 4, b.y, 8, 20); }
                else if(b.type === 'PULSE') { ctx.fillStyle = '#00f2ff'; ctx.shadowColor = '#00f2ff'; ctx.fillRect(b.x - 1, b.y, 2, 12); }
                else if(b.type === 'BURST') { ctx.fillStyle = '#ffcc00'; ctx.shadowColor = '#ffcc00'; ctx.fillRect(b.x - 2, b.y, 4, 10); }
                else if(b.type === 'EMP') { ctx.fillStyle = '#39ff14'; ctx.shadowColor = '#39ff14'; ctx.fillRect(b.x - 5, b.y, 10, 10); }
                else { ctx.fillStyle = '#fff'; ctx.shadowColor = '#00f2ff'; ctx.fillRect(Math.floor(b.x - 2), Math.floor(b.y), 4, 15); }
                ctx.shadowBlur = 0;
            });

            this.enemyBullets.forEach(eb => {
                ctx.fillStyle = '#ff3131'; ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
                ctx.beginPath(); ctx.arc(Math.floor(eb.x), Math.floor(eb.y), 6, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            });

            this.squad.forEach(u => { this.drawPixelObj(0, u.color, u.x, u.y, 0.7); });
        }
    }

    gameOver() { 
        this.active = false; this.isFiring = false; this.totalCredits += this.creditsThisRun; 
        this.updateHUDVisibility(false);
        document.getElementById('death-overlay').style.display = 'flex'; 
    }
    victory() { 
        this.active = false; this.isFiring = false; this.totalCredits += this.creditsThisRun + 1000; 
        this.updateHUDVisibility(false);
        document.getElementById('victory-overlay').style.display = 'flex'; 
    }
    showMenu() { 
        this.active = false; this.isFiring = false; this.updateHUDVisibility(false);
        document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none');
        document.getElementById('menu-overlay').style.display = 'flex'; 
    }
    openMarket() {
        this.updateHUDVisibility(false);
        document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none');
        document.getElementById('market-overlay').style.display = 'flex';
        document.getElementById('market-credits').innerText = Math.floor(this.totalCredits);
        const container = document.getElementById('market-items');
        const list = [
            { id: 'hull', n: `STRUCTURAL HULL (+${this.upgrades.hull})`, p: 1000 },
            { id: 'speed', n: `PLASMA FIRE RATE (+${this.upgrades.speed})`, p: 1500 },
            { id: 'perma', n: `PERMANENT MERCENARY`, p: 5000 },
            { id: 'temp', n: `SECTOR MERCENARY (TEMP)`, p: 800 },
            { id: 'c1', n: 'PAINT: NEON PINK', p: 500, c: '#ff0077' },
            { id: 'c2', n: 'PAINT: NEON GREEN', p: 500, c: '#39ff14' },
            { id: 'c3', n: 'PAINT: NEON PURPLE', p: 500, c: '#bc13fe' }
        ];
        container.innerHTML = list.map(i => {
            const dis = this.totalCredits < i.p;
            const click = i.c ? `game.buyColor('${i.c}', ${i.p})` : `game.buyUp('${i.id}', ${i.p})`;
            return `<button class="btn" ${dis ? 'disabled' : ''} onclick="${click}">${i.n} - ${i.p} CR</button>`;
        }).join('');
    }
    buyUp(id, p) { if(this.totalCredits >= p){ this.totalCredits -= p; this.upgrades[id]++; this.openMarket(); } }
    buyColor(c, p) { if(this.totalCredits >= p){ this.totalCredits -= p; this.upgrades.color = c; this.openMarket(); } }
    closeMarket() { this.showMenu(); }
    loop() { this.update(); this.draw(); requestAnimationFrame(() => this.loop()); }
}

const game = new Game();
</script>
</body>
</html>
