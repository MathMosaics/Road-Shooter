<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Road: Ultimate Squad</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff0077;
            --neon-purple: #bc13fe;
            --neon-red: #ff3131;
            --neon-yellow: #ffcc00;
            --neon-green: #39ff14;
            --neon-orange: #ff8c00;
        }
        body { 
            margin: 0; 
            background: #050508; 
            color: #fff; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            touch-action: none;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 242, 255, 0.2);
            background: #000;
            border: 1px solid #111;
        }
        canvas { 
            display: block;
            max-width: 100vw;
            max-height: 100vh;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            z-index: 5;
        }
        .stat-box { 
            background: rgba(0,0,0,0.7); 
            padding: 8px 12px; 
            border-left: 3px solid var(--neon-blue);
            backdrop-filter: blur(5px);
        }
        .stat-label { font-size: 10px; color: var(--neon-blue); display: block; text-transform: uppercase; letter-spacing: 2px; }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            padding: 20px;
            box-sizing: border-box;
        }
        h2 { color: var(--neon-pink); font-size: 42px; margin: 0; text-shadow: 0 0 15px var(--neon-pink); letter-spacing: 4px; }
        p { margin: 15px 0; color: #888; font-size: 14px; max-width: 250px; line-height: 1.5; }
        
        .btn {
            padding: 16px 32px;
            font-size: 14px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid var(--neon-blue);
            background: transparent;
            color: var(--neon-blue);
            margin: 10px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            width: 240px;
            pointer-events: auto;
            letter-spacing: 1px;
        }
        .btn:hover:not(:disabled) {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px var(--neon-blue);
            transform: scale(1.05);
        }
        .btn:disabled { border-color: #333; color: #333; cursor: not-allowed; }
        
        .shop-grid {
            width: 100%;
            max-width: 340px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            pointer-events: auto;
            max-height: 45vh;
            overflow-y: auto;
            padding-right: 5px;
        }
        .shop-grid::-webkit-scrollbar { width: 4px; }
        .shop-grid::-webkit-scrollbar-thumb { background: var(--neon-blue); border-radius: 10px; }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0a0a0f;
            padding: 15px;
            border: 1px solid #222;
            cursor: pointer;
            transition: border 0.2s;
        }
        .shop-item.active { border-color: var(--neon-green); background: rgba(57, 255, 20, 0.05); }
        .shop-item:hover { border-color: var(--neon-blue); }
        .item-info { text-align: left; }
        .item-name { display: block; font-size: 14px; color: var(--neon-blue); font-weight: bold; }
        .item-lvl { font-size: 11px; color: #666; margin-top: 2px; display: block; }
        .item-cost { font-weight: bold; color: var(--neon-yellow); font-size: 16px; }

        #fire-hint {
            position: absolute;
            bottom: 60px;
            width: 100%;
            text-align: center;
            color: var(--neon-blue);
            font-size: 12px;
            letter-spacing: 3px;
            opacity: 0.5;
            pointer-events: none;
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.7; }
            100% { opacity: 0.3; }
        }
        #weapon-tag {
            font-size: 10px;
            color: var(--neon-green);
            margin-top: 4px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div class="stat-box">
            <span class="stat-label">Currency</span>
            <span id="coin-display">0</span>
            <span id="weapon-tag">PLASMA</span>
        </div>
        <div class="stat-box" style="text-align: right;">
            <span class="stat-label">Squad Rank</span>
            <span id="squad-display">1</span>
        </div>
    </div>

    <div id="fire-hint" style="display:none;">Slide to Move & Fire</div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h2>NEON ROAD</h2>
        <p>The high-speed neon battle for the grid. Command your squad and survive the road.</p>
        <button class="btn" onclick="game.start()">Initiate Protocol</button>
        <button class="btn" onclick="game.openShop()">Upgrade Depot</button>
    </div>

    <div id="shop-overlay" class="overlay">
        <h2>DEPOT</h2>
        <p>Enhance your squad's firepower and tech capabilities.</p>
        <div id="shop-items" class="shop-grid"></div>
        <button class="btn" onclick="game.toggleOverlay('shop-overlay', false)">Return to Grid</button>
    </div>

    <div id="death-overlay" class="overlay">
        <h2 id="death-title">SQUAD LOST</h2>
        <p id="death-msg">Mission failed. The grid has reclaimed your energy.</p>
        <button id="btn-buyback" class="btn" onclick="game.buyback()">Emergency Reboot (400)</button>
        <button class="btn" style="border-color: var(--neon-pink); color: var(--neon-pink)" onclick="game.stop()">End Mission</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GAME_WIDTH = 400;
const GAME_HEIGHT = 700;
const LANE_WIDTH = GAME_WIDTH / 2;
const BUYBACK_COST = 400;
const SOLDIERS_PER_RANK = 5;

canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

const WEAPONS = {
    plasma: { name: 'PLASMA', color: '#00f2ff', type: 'projectile', cost: 0 },
    pulse: { name: 'PULSE', color: '#bc13fe', type: 'pierce', cost: 5000 },
    nova: { name: 'NOVA', color: '#ffcc00', type: 'explosive', cost: 12000 }
};

class Game {
    constructor() {
        this.loadData();
        this.reset(true);
        this.setupListeners();
        this.spawnQueue = [];
        this.loop();
    }

    loadData() {
        const saved = localStorage.getItem('neon_road_pro_v1');
        this.upgrades = saved ? JSON.parse(saved) : {
            multiShot: 0,
            fireRate: 0,
            damage: 0,
            coinGain: 0,
            weaponType: 'plasma',
            ownedWeapons: ['plasma']
        };
        this.totalCoins = parseInt(localStorage.getItem('neon_road_coins_pro')) || 0;
        this.updateUI();
    }

    saveData() {
        localStorage.setItem('neon_road_pro_v1', JSON.stringify(this.upgrades));
        localStorage.setItem('neon_road_coins_pro', Math.floor(this.totalCoins));
    }

    reset() {
        this.playerLane = 0;
        this.currentX = (0 * LANE_WIDTH) + (LANE_WIDTH / 2);
        this.entities = [];
        this.bullets = [];
        this.particles = [];
        this.frame = 0;
        this.isActive = false;
        this.isFiring = false; 
        this.squadSize = 1 + this.upgrades.multiShot;
        this.fireRate = 14 - (this.upgrades.fireRate * 1.2);
        this.damage = 1 + (this.upgrades.damage * 0.5);
        this.currentWeapon = WEAPONS[this.upgrades.weaponType || 'plasma'];
        this.shake = 0;
        this.bossTimer = 0;
        this.activeBoss = null;
        this.spawnQueue = [];
        document.getElementById('fire-hint').style.display = 'none';
        document.getElementById('weapon-tag').innerText = this.currentWeapon.name;
    }

    setupListeners() {
        const updatePos = (clientX) => {
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left) * (GAME_WIDTH / rect.width);
            this.playerLane = x < (GAME_WIDTH / 2) ? 0 : 1;
        };
        canvas.addEventListener('touchstart', e => { 
            e.preventDefault(); 
            this.isFiring = this.isActive; 
            updatePos(e.touches[0].clientX); 
        }, {passive: false});
        canvas.addEventListener('touchmove', e => { 
            e.preventDefault(); 
            updatePos(e.touches[0].clientX); 
        }, {passive: false});
        canvas.addEventListener('touchend', () => this.isFiring = false);
        canvas.addEventListener('mousedown', e => { 
            this.isFiring = this.isActive; 
            updatePos(e.clientX); 
        });
        window.addEventListener('mousemove', e => { if (this.isFiring) updatePos(e.clientX); });
        window.addEventListener('mouseup', () => this.isFiring = false);
    }

    start() {
        this.reset();
        this.isActive = true;
        this.toggleOverlay('menu-overlay', false);
        this.toggleOverlay('death-overlay', false);
        document.getElementById('fire-hint').style.display = 'block';
    }

    stop() {
        this.isActive = false;
        this.isFiring = false;
        this.toggleOverlay('death-overlay', false);
        this.toggleOverlay('menu-overlay', true);
        this.saveData();
    }

    toggleOverlay(id, show) {
        document.getElementById(id).style.display = show ? 'flex' : 'none';
    }

    openShop() {
        this.renderShop();
        this.toggleOverlay('shop-overlay', true);
    }

    updateUI() {
        const coinEl = document.getElementById('coin-display');
        const squadEl = document.getElementById('squad-display');
        if (coinEl) coinEl.innerText = Math.floor(this.totalCoins);
        if (squadEl) squadEl.innerText = Math.floor(this.squadSize);
    }

    getPowerRating() {
        let weaponMult = this.currentWeapon.type === 'plasma' ? 1 : 1.4;
        return (this.squadSize * this.damage * (10 / this.fireRate)) * weaponMult;
    }

    spawn() {
        const lane = Math.random() > 0.5 ? 1 : 0;
        const x = (lane * LANE_WIDTH) + (LANE_WIDTH / 2);
        const power = this.getPowerRating();
        
        if (this.bossTimer > 2800 && !this.activeBoss) {
            this.spawnBoss();
            this.bossTimer = 0;
            return;
        }

        if (Math.random() < 0.12 && power > 25) {
            this.queueSwarm(power);
            return;
        }

        if (Math.random() > 0.72) {
            const isHazard = Math.random() > 0.75;
            let startVal = isHazard ? -(Math.floor(Math.random() * 40 + 15)) : Math.floor(Math.random() * 8 + 2);
            const hitsToBreak = Math.abs(startVal) * (1.3 + (power / 45));
            
            this.entities.push({
                type: 'barrier', x, y: -60, hp: 0, 
                maxHp: hitsToBreak * this.damage, 
                value: startVal, originalValue: startVal,
                speed: 3 + (this.frame/9000),
                lane, isHazard, pulse: 0
            });
        } else {
            this.spawnMonster(x, lane, power);
        }
    }

    spawnMonster(x, lane, power) {
        const types = [
            { id: 'phantom', color: '#00f2ff', hp: 1.2, speed: 6.5, weight: 35, scale: 0.8 },
            { id: 'stalker', color: '#ff0077', hp: 4.5, speed: 4, weight: 40, scale: 1 },
            { id: 'glitch', color: '#39ff14', hp: 3, speed: 5.5, weight: 15, scale: 1, glitch: true },
            { id: 'goliath', color: '#ff8c00', hp: 22, speed: 2, weight: 10, scale: 1.9 }
        ];

        let roll = Math.random() * 100;
        let selected = types[0];
        let rw = 0;
        for (let t of types) { rw += t.weight; if (roll <= rw) { selected = t; break; } }

        const hpMult = 1 + (power / 90) + (this.frame / 5000);
        this.entities.push({
            type: 'monster', monsterId: selected.id, 
            x, y: -50, hp: selected.hp * hpMult,
            speed: selected.speed * (1 + (power / 700)), 
            lane, color: selected.color, scale: selected.scale,
            glitch: selected.glitch
        });
    }

    queueSwarm(power) {
        const count = 4 + Math.floor(power/25);
        for(let i=0; i<count; i++) {
            this.spawnQueue.push({ delay: i * 12, x: (Math.random() > 0.5 ? 0.5 : 1.5) * (GAME_WIDTH / 2), power });
        }
    }

    spawnBoss() {
        const hp = 400 + (this.getPowerRating() * 8);
        this.activeBoss = { type: 'boss', x: GAME_WIDTH / 2, y: -150, hp, maxHp: hp, speed: 1.2, targetY: 150 };
        this.entities.push(this.activeBoss);
    }

    update() {
        if (!this.isActive) return;
        this.frame++;
        this.bossTimer++;
        if (this.shake > 0) this.shake *= 0.9;

        const targetX = (this.playerLane * LANE_WIDTH) + (LANE_WIDTH / 2);
        this.currentX += (targetX - this.currentX) * 0.2;

        this.totalCoins += 0.5 * (1 + (this.upgrades.coinGain * 0.25));

        // Process Spawn Queue safely
        for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
            this.spawnQueue[i].delay--;
            if (this.spawnQueue[i].delay <= 0) {
                const s = this.spawnQueue.splice(i, 1)[0];
                this.spawnMonster(s.x, 0, s.power);
            }
        }

        const spawnFreq = Math.max(12, 65 - Math.floor(this.getPowerRating()/1.6));
        if (this.frame % spawnFreq === 0) this.spawn();
        if (this.isFiring && this.frame % Math.max(1, Math.floor(this.fireRate)) === 0) this.fire();

        for (let i = this.entities.length - 1; i >= 0; i--) {
            const e = this.entities[i];
            e.y += e.speed;
            if (e.glitch) e.x += Math.sin(this.frame * 0.15) * 4;
            if (e.type === 'boss') e.x = (GAME_WIDTH/2) + Math.sin(this.frame * 0.04) * 120;

            this.bullets.forEach((b, bi) => {
                const dist = Math.hypot(b.x - e.x, b.y - e.y);
                const hitRadius = e.type === 'boss' ? 95 : (42 * (e.scale || 1));
                if (dist < hitRadius) {
                    this.handleHit(e, b);
                    if (this.currentWeapon.type !== 'pierce') this.bullets.splice(bi, 1);
                }
            });

            if (!this.entities[i]) continue;
            if (e.type !== 'barrier' && e.hp <= 0) {
                this.entities.splice(i, 1);
                this.totalCoins += (e.type === 'boss' ? 5000 : 40);
                if (e.type === 'boss') this.activeBoss = null;
                continue;
            }
            
            if (Math.abs(e.y - (GAME_HEIGHT - 100)) < 55) {
                if (Math.abs(e.x - this.currentX) < (e.type === 'boss' ? 105 : 50)) {
                    if (e.type === 'barrier') {
                        this.squadSize += e.isHazard ? (this.squadSize * (e.value/100)) : e.originalValue;
                        this.entities.splice(i, 1);
                        if (this.squadSize < 1) this.die();
                    } else { this.die(); }
                }
            }
            if (e.y > GAME_HEIGHT + 150) this.entities.splice(i, 1);
        }

        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            b.y -= b.vy || 16; 
            if (b.life !== undefined) {
                b.life--;
                if (b.life <= 0) this.bullets.splice(i, 1);
            } else if (b.y < -100) this.bullets.splice(i, 1);
        }

        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.03; 
            if (p.life <= 0) this.particles.splice(i, 1); 
        }
    }

    handleHit(entity, bullet) {
        const dmg = this.damage * (bullet.dmgMult || 1);
        if (entity.type === 'barrier') {
            entity.hp += dmg;
            if (entity.hp >= entity.maxHp) {
                this.squadSize += entity.isHazard ? 0 : entity.originalValue;
                this.createExplosion(entity.x, entity.y, entity.isHazard ? '#ff3131' : '#00f2ff', 25);
                const idx = this.entities.indexOf(entity);
                if (idx > -1) this.entities.splice(idx, 1);
            }
        } else { entity.hp -= dmg; }

        if (this.currentWeapon.type === 'explosive') {
            this.createExplosion(bullet.x, bullet.y, this.currentWeapon.color, 20);
            this.shake = 12;
            this.entities.forEach(near => {
                if (near === entity) return;
                if (Math.hypot(near.x - bullet.x, near.y - bullet.y) < 120) near.hp -= dmg * 0.7;
            });
        }
        this.createExplosion(bullet.x, bullet.y, '#fff', 4);
    }

    die() {
        this.isActive = false;
        this.toggleOverlay('death-overlay', true);
        const btn = document.getElementById('btn-buyback');
        if (btn) btn.disabled = this.totalCoins < BUYBACK_COST;
        this.saveData();
    }

    buyback() {
        if (this.totalCoins >= BUYBACK_COST) {
            this.totalCoins -= BUYBACK_COST;
            this.isActive = true;
            this.squadSize = Math.max(2, Math.floor(this.squadSize));
            this.toggleOverlay('death-overlay', false);
            this.entities = this.entities.filter(e => e.y < 200); 
        }
    }

    fire() {
        const count = Math.min(60, Math.floor(this.squadSize));
        const weapon = this.currentWeapon;
        for (let i = 0; i < count; i++) {
            const pos = this.getSoldierPosition(i, this.currentX, GAME_HEIGHT - 100);
            if (weapon.type === 'pierce') {
                this.bullets.push({ x: pos.x, y: pos.y, vy: 10, life: 60, isPulse: true });
            } else if (weapon.type === 'explosive') {
                this.bullets.push({ x: pos.x, y: pos.y, vy: 12, dmgMult: 2.5 });
            } else {
                this.bullets.push({ x: pos.x, y: pos.y, vy: 20 });
            }
        }
    }

    getSoldierPosition(index, centerX, baseY) {
        const row = Math.floor(index / SOLDIERS_PER_RANK);
        const col = index % SOLDIERS_PER_RANK;
        const soldiersInRow = Math.min(SOLDIERS_PER_RANK, Math.floor(this.squadSize) - (row * SOLDIERS_PER_RANK));
        const spacingX = 24, spacingY = 32;
        const rowOffset = ((soldiersInRow - 1) * spacingX) / 2;
        return { x: centerX - rowOffset + (col * spacingX), y: baseY + (row * spacingY) };
    }

    createExplosion(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y, vx: (Math.random() - 0.5) * 14, vy: (Math.random() - 0.5) * 14,
                life: 1, color
            });
        }
    }

    renderShop() {
        const items = [
            { id: 'plasma', name: 'Standard Plasma', type: 'weapon', cost: 0, desc: 'Reliable fast-fire pulse.' },
            { id: 'pulse', name: 'Pulse Cannon', type: 'weapon', cost: 5000, desc: 'Piercing energy waves.' },
            { id: 'nova', name: 'Nova Launcher', type: 'weapon', cost: 12000, desc: 'Heavy area explosions.' },
            { id: 'multiShot', name: 'Squad Reinforcement', cost: 2000, type: 'upg', desc: '+1 Permanent Unit' },
            { id: 'damage', name: 'Overclocked Cores', cost: 1500, type: 'upg', desc: '+50% Base Damage' }
        ];

        const container = document.getElementById('shop-items');
        if (!container) return;
        container.innerHTML = '';
        items.forEach(item => {
            const isWeapon = item.type === 'weapon';
            const owned = isWeapon ? this.upgrades.ownedWeapons.includes(item.id) : false;
            const active = isWeapon && this.upgrades.weaponType === item.id;
            const lvl = !isWeapon ? this.upgrades[item.id] : 0;
            const cost = isWeapon ? item.cost : item.cost * (lvl + 1);

            const div = document.createElement('div');
            div.className = `shop-item ${active ? 'active' : ''}`;
            div.onclick = () => isWeapon ? this.selectWeapon(item.id, cost) : this.buyUpgrade(item.id, cost);
            
            div.innerHTML = `
                <div class="item-info">
                    <span class="item-name">${item.name} ${active ? 'âœ“' : ''}</span>
                    <span class="item-lvl">${isWeapon ? item.desc : 'Rank ' + lvl}</span>
                </div>
                <div class="item-cost">${(isWeapon && owned) ? 'READY' : cost}</div>
            `;
            container.appendChild(div);
        });
    }

    selectWeapon(id, cost) {
        if (this.upgrades.ownedWeapons.includes(id)) {
            this.upgrades.weaponType = id;
        } else if (this.totalCoins >= cost) {
            this.totalCoins -= cost;
            this.upgrades.ownedWeapons.push(id);
            this.upgrades.weaponType = id;
        }
        this.saveData(); this.renderShop(); this.updateUI();
    }

    buyUpgrade(id, cost) {
        if (this.totalCoins >= cost) {
            this.totalCoins -= cost;
            this.upgrades[id]++;
            this.saveData(); this.renderShop(); this.updateUI();
        }
    }

    draw() {
        ctx.save();
        if (this.shake > 1) ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake);
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Road Lines
        ctx.strokeStyle = 'rgba(0, 242, 255, 0.1)'; ctx.setLineDash([20, 40]);
        ctx.beginPath(); ctx.moveTo(GAME_WIDTH/2, 0); ctx.lineTo(GAME_WIDTH/2, GAME_HEIGHT); ctx.stroke();
        ctx.setLineDash([]);

        this.particles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;

        this.bullets.forEach(b => {
            ctx.fillStyle = this.currentWeapon.color;
            if (b.isPulse) {
                ctx.beginPath(); ctx.arc(b.x, b.y, 14, 0, Math.PI*2); ctx.lineWidth=2; ctx.strokeStyle=this.currentWeapon.color; ctx.stroke();
            } else {
                ctx.fillRect(b.x - 3, b.y, 6, 24);
                ctx.shadowBlur = 10; ctx.shadowColor = this.currentWeapon.color;
            }
        });
        ctx.shadowBlur = 0;

        this.entities.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            const s = e.scale || 1;
            ctx.scale(s, s);

            if (e.type === 'barrier') {
                const color = e.isHazard ? '#ff3131' : '#00f2ff';
                ctx.strokeStyle = color; ctx.lineWidth = 4;
                ctx.strokeRect(-65, -30, 130, 60);
                ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(-65, -30, 130, 60);
                ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.font = 'bold 26px Arial';
                ctx.fillText(e.value + (e.isHazard ? "%" : ""), 0, 10);
                ctx.fillStyle = '#222'; ctx.fillRect(-50, -25, 100, 6);
                ctx.fillStyle = color; ctx.fillRect(-50, -25, (e.hp/e.maxHp)*100, 6);
            } else if (e.type === 'boss') {
                ctx.fillStyle = '#ff0077'; ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 65, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#111'; ctx.fillRect(-110, 100, 220, 12);
                ctx.fillStyle = '#ff0077'; ctx.fillRect(-110, 100, (e.hp/e.maxHp)*220, 12);
            } else {
                this.drawMonster(ctx, e);
            }
            ctx.restore();
        });

        const displaySquad = Math.floor(this.squadSize);
        for (let i = 0; i < displaySquad; i++) {
            const pos = this.getSoldierPosition(i, this.currentX, GAME_HEIGHT - 100);
            ctx.fillStyle = '#00f2ff'; 
            ctx.beginPath(); ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        }
        ctx.restore();
    }

    drawMonster(ctx, e) {
        ctx.fillStyle = e.color;
        ctx.shadowBlur = 10; ctx.shadowColor = e.color;
        if(e.monsterId === 'goliath') {
            ctx.fillRect(-28, -28, 56, 56);
        } else if(e.monsterId === 'phantom') {
            ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(18, 18); ctx.lineTo(-18, 18); ctx.closePath(); ctx.fill();
        } else {
            ctx.beginPath(); ctx.moveTo(-22, 22); ctx.lineTo(0, -28); ctx.lineTo(22, 22); ctx.closePath(); ctx.fill();
        }
        ctx.shadowBlur = 0;
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

const game = new Game();
</script>
</body>
</html>
