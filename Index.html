<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Road: Refined Combat</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff0077;
            --neon-purple: #bc13fe;
            --neon-red: #ff3131;
            --neon-yellow: #ffcc00;
            --neon-green: #39ff14;
        }
        body { 
            margin: 0; background: #050508; color: #fff; 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            overflow: hidden; touch-action: none;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }
        #game-container {
            position: relative; background: #000; width: 100%; height: 100%; max-width: 600px;
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        
        #ui-layer {
            position: absolute; top: 10px; left: 0; width: 100%; padding: 15px;
            box-sizing: border-box; pointer-events: none; display: flex;
            justify-content: space-between; z-index: 5;
        }
        .stat-box { background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); }
        .stat-label { font-size: 9px; color: var(--neon-blue); display: block; text-transform: uppercase; letter-spacing: 1.5px; }
        .stat-value { font-size: 18px; font-weight: 900; }

        #xp-container { position: absolute; top: 0; left: 0; width: 100%; height: 6px; background: rgba(255,255,255,0.05); z-index: 10; }
        #xp-bar { height: 100%; width: 0%; background: var(--neon-green); box-shadow: 0 0 10px var(--neon-green); transition: width 0.3s; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.95); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20; padding: 20px;
            box-sizing: border-box; backdrop-filter: blur(15px);
        }
        h2 { color: var(--neon-pink); font-size: 32px; margin: 0; text-shadow: 0 0 20px var(--neon-pink); }
        .btn {
            padding: 16px; font-size: 14px; font-weight: bold; cursor: pointer;
            border: 2px solid var(--neon-blue); background: rgba(0, 242, 255, 0.1);
            color: var(--neon-blue); margin: 8px; border-radius: 12px;
            text-transform: uppercase; width: 100%; max-width: 280px; pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="xp-container"><div id="xp-bar"></div></div>
    
    <div id="ui-layer">
        <div class="stat-box">
            <span class="stat-label">Stash</span>
            <span id="coin-display" class="stat-value">0</span>
        </div>
        <div class="stat-box" style="text-align: right;">
            <span class="stat-label">Mission Rank</span>
            <span id="rank-display" class="stat-value">1</span>
        </div>
    </div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h2>NEON ROAD</h2>
        <button class="btn" onclick="game.start()">Engage Engines</button>
        <button class="btn" style="border-color: var(--neon-purple); color: var(--neon-purple);" onclick="game.openShop()">Upgrade Armory</button>
    </div>

    <div id="shop-overlay" class="overlay">
        <h2 style="color: var(--neon-purple)">THE ARMORY</h2>
        <div id="shop-items" style="width:100%; margin:20px 0;"></div>
        <button class="btn" onclick="game.toggleOverlay('shop-overlay', false)">Back</button>
    </div>

    <div id="death-overlay" class="overlay">
        <h2 style="color: var(--neon-red)">SQUAD LOST</h2>
        <button class="btn" onclick="game.start()">Restart</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width, height;

function resize() {
    const container = document.getElementById('game-container');
    width = container.clientWidth;
    height = container.clientHeight;
    canvas.width = width;
    canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

class Game {
    constructor() {
        this.loadData();
        this.reset();
        this.setupInput();
        this.loop();
    }

    loadData() {
        const saved = localStorage.getItem('neon_road_precise_v2');
        this.upgrades = saved ? JSON.parse(saved) : {
            squadCap: 0, damage: 0, fireRate: 0
        };
        this.totalCoins = parseInt(localStorage.getItem('neon_road_coins')) || 0;
    }

    saveData() {
        localStorage.setItem('neon_road_precise_v2', JSON.stringify(this.upgrades));
        localStorage.setItem('neon_road_coins', Math.floor(this.totalCoins));
    }

    reset() {
        this.isActive = false;
        this.frame = 0;
        this.entities = [];
        this.bullets = [];
        this.enemyBullets = [];
        this.particles = [];
        
        this.playerX = width / 2;
        this.targetX = width / 2;
        
        this.rank = 1;
        this.xp = 0;
        this.xpToNext = 100;
        
        this.squadCount = 1 + this.upgrades.squadCap;
        this.damage = 1 + (this.upgrades.damage * 1);
        this.fireCooldown = 0;
        
        this.updateUI();
    }

    setupInput() {
        const handleMove = (clientX) => {
            if (!this.isActive) return;
            const rect = canvas.getBoundingClientRect();
            this.targetX = clientX - rect.left;
        };
        canvas.addEventListener('touchstart', (e) => handleMove(e.touches[0].clientX));
        canvas.addEventListener('touchmove', (e) => handleMove(e.touches[0].clientX));
        canvas.addEventListener('mousedown', (e) => { this.mouseDown = true; handleMove(e.clientX); });
        window.addEventListener('mousemove', (e) => { if(this.mouseDown) handleMove(e.clientX); });
        window.addEventListener('mouseup', () => this.mouseDown = false);
    }

    start() {
        this.reset();
        this.isActive = true;
        this.toggleOverlay('menu-overlay', false);
        this.toggleOverlay('death-overlay', false);
    }

    toggleOverlay(id, show) {
        document.getElementById(id).style.display = show ? 'flex' : 'none';
    }

    updateUI() {
        document.getElementById('coin-display').innerText = Math.floor(this.totalCoins);
        document.getElementById('rank-display').innerText = this.rank;
        document.getElementById('xp-bar').style.width = `${(this.xp / this.xpToNext) * 100}%`;
    }

    spawn() {
        const x = Math.random() * (width - 100) + 50;
        const levelMod = 1 + (this.rank * 0.2);

        if (Math.random() > 0.6) {
            // GATES
            const isNegative = Math.random() > 0.8;
            const val = isNegative ? -Math.floor(Math.random()*3 + 1) : Math.floor(Math.random()*5 + 1);
            this.entities.push({
                type: 'gate', x, y: -100, value: val, 
                hp: 10 * levelMod, maxHp: 10 * levelMod,
                speed: 3 + (this.rank * 0.1),
                hitTimer: 0
            });
        } else {
            // MONSTERS
            const hp = 5 * levelMod;
            this.entities.push({
                type: 'enemy', x, y: -100, hp, maxHp: hp, 
                speed: 4 + Math.random() * 2,
                fireTimer: Math.random() * 60,
                hitTimer: 0
            });
        }
    }

    update() {
        if (!this.isActive) return;
        this.frame++;

        // Smooth follow
        this.playerX += (this.targetX - this.playerX) * 0.2;

        if (this.frame % 40 === 0) this.spawn();

        // Fire logic
        this.fireCooldown--;
        if (this.fireCooldown <= 0) {
            this.fire();
            this.fireCooldown = Math.max(5, 15 - this.upgrades.fireRate);
        }

        // Entities loop
        for (let i = this.entities.length - 1; i >= 0; i--) {
            const e = this.entities[i];
            e.y += e.speed;
            if (e.hitTimer > 0) e.hitTimer--;

            if (e.type === 'enemy') {
                e.fireTimer++;
                if (e.fireTimer > 90) {
                    this.enemyBullets.push({ x: e.x, y: e.y, vy: 6 });
                    e.fireTimer = 0;
                }
            }

            // Bullet -> Entity Collision
            for (let j = this.bullets.length - 1; j >= 0; j--) {
                const b = this.bullets[j];
                const dx = Math.abs(b.x - e.x);
                const dy = Math.abs(b.y - e.y);
                
                const hitW = e.type === 'gate' ? 70 : 30;
                const hitH = e.type === 'gate' ? 40 : 30;

                if (dx < hitW && dy < hitH) {
                    e.hp -= this.damage;
                    e.hitTimer = 3; // Flash white
                    this.bullets.splice(j, 1);

                    // If it's a gate, update the visual value based on damage
                    if (e.type === 'gate' && e.hp > 0 && e.value > 0) {
                        // Every 2 points of damage reduces gate value by 1 (optional mechanic)
                        // Or just let the gate stay until HP is 0
                    }

                    if (e.hp <= 0) {
                        if (e.type === 'gate') {
                            this.squadCount += e.value;
                            this.createExplosion(e.x, e.y, e.value > 0 ? '#00f2ff' : '#f00');
                        } else {
                            this.totalCoins += 10 * this.rank;
                            this.xp += 15;
                            this.createExplosion(e.x, e.y, '#ff0077');
                            if (this.xp >= this.xpToNext) this.rankUp();
                        }
                        this.entities.splice(i, 1);
                        break;
                    }
                }
            }

            // Player -> Entity Collision (Physical)
            if (e && Math.abs(e.y - (height - 150)) < 30 && Math.abs(e.x - this.playerX) < 40) {
                if (e.type === 'gate') {
                    this.squadCount += e.value;
                    this.entities.splice(i, 1);
                    if (this.squadCount < 1) this.die();
                } else {
                    this.takeDamage(5); // Ramming a monster hurts a lot
                    this.entities.splice(i, 1);
                }
            }

            if (e && e.y > height + 100) this.entities.splice(i, 1);
        }

        // Bullets movement
        this.bullets.forEach((b, i) => {
            b.y -= 15;
            if (b.y < -50) this.bullets.splice(i, 1);
        });

        // Enemy Bullets movement
        for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
            const eb = this.enemyBullets[i];
            eb.y += eb.vy;
            
            // Tightened Hitbox (Player is at y: height-150, size approx 30px)
            const pdx = Math.abs(eb.x - this.playerX);
            const pdy = Math.abs(eb.y - (height - 150));
            
            if (pdx < 20 && pdy < 20) {
                this.takeDamage(1);
                this.enemyBullets.splice(i, 1);
            } else if (eb.y > height + 50) {
                this.enemyBullets.splice(i, 1);
            }
        }

        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.02;
            if (p.life <= 0) this.particles.splice(i, 1);
        });
        
        if (this.squadCount < 1) this.die();
        this.updateUI();
    }

    takeDamage(amt) {
        this.squadCount -= amt;
        this.createExplosion(this.playerX, height - 150, '#ff3131', 5);
        if (this.squadCount < 1) this.die();
    }

    rankUp() {
        this.rank++;
        this.xp = 0;
        this.xpToNext = Math.floor(this.xpToNext * 1.4);
        this.createExplosion(width/2, height/2, '#39ff14', 20);
    }

    fire() {
        const count = Math.min(12, Math.max(1, Math.floor(this.squadCount)));
        for (let i = 0; i < count; i++) {
            const offset = (i - (count - 1) / 2) * 12;
            this.bullets.push({ x: this.playerX + offset, y: height - 160 });
        }
    }

    createExplosion(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y, color, life: 1,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10
            });
        }
    }

    die() {
        this.isActive = false;
        this.toggleOverlay('death-overlay', true);
        this.saveData();
    }

    draw() {
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, width, height);

        // Draw entities
        this.entities.forEach(e => {
            ctx.save();
            if (e.hitTimer > 0) ctx.filter = 'brightness(3)';
            
            if (e.type === 'gate') {
                const color = e.value > 0 ? '#00f2ff' : '#ff3131';
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(e.x - 60, e.y - 30, 120, 60);
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(e.x - 60, e.y - 30, 120, 60);
                
                // HP Bar for Gate
                ctx.fillStyle = '#222';
                ctx.fillRect(e.x - 40, e.y + 15, 80, 4);
                ctx.fillStyle = color;
                ctx.fillRect(e.x - 40, e.y + 15, (e.hp/e.maxHp)*80, 4);

                ctx.fillStyle = color;
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'center';
                ctx.fillText((e.value > 0 ? '+' : '') + e.value, e.x, e.y + 8);
            } else {
                // Enemy Monster
                ctx.fillStyle = '#ff0077';
                ctx.beginPath();
                ctx.moveTo(e.x, e.y + 20);
                ctx.lineTo(e.x + 20, e.y - 15);
                ctx.lineTo(e.x - 20, e.y - 15);
                ctx.closePath();
                ctx.fill();
                // HP bar
                ctx.fillStyle = '#222';
                ctx.fillRect(e.x - 15, e.y - 25, 30, 3);
                ctx.fillStyle = '#ff0077';
                ctx.fillRect(e.x - 15, e.y - 25, (e.hp/e.maxHp)*30, 3);
            }
            ctx.restore();
        });

        // Bullets
        ctx.fillStyle = '#00f2ff';
        this.bullets.forEach(b => ctx.fillRect(b.x-2, b.y, 4, 15));

        // Enemy Bullets
        ctx.fillStyle = '#ff3131';
        this.enemyBullets.forEach(eb => {
            ctx.beginPath(); ctx.arc(eb.x, eb.y, 5, 0, Math.PI*2); ctx.fill();
        });

        // Particles
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;

        // Player Squad
        const sCount = Math.max(1, Math.floor(this.squadCount));
        ctx.fillStyle = '#00f2ff';
        for (let i = 0; i < sCount; i++) {
            const row = Math.floor(i / 4);
            const col = i % 4;
            const px = this.playerX + (col - 1.5) * 15;
            const py = (height - 150) + row * 15;
            ctx.beginPath();
            ctx.moveTo(px, py - 10); ctx.lineTo(px + 7, py + 5); ctx.lineTo(px - 7, py + 5);
            ctx.closePath();
            ctx.fill();
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    openShop() {
        const container = document.getElementById('shop-items');
        container.innerHTML = '';
        const items = [
            { id: 'squadCap', name: 'Reinforcements', cost: 500 },
            { id: 'fireRate', name: 'Rapid Fire', cost: 400 },
            { id: 'damage', name: 'Heavy Bolts', cost: 600 }
        ];
        items.forEach(item => {
            const level = this.upgrades[item.id];
            const cost = Math.floor(item.cost * Math.pow(1.6, level));
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.style.width = '100%';
            btn.innerHTML = `${item.name} (Lvl ${level})<br><small>${cost} Coins</small>`;
            btn.onclick = () => {
                if (this.totalCoins >= cost) {
                    this.totalCoins -= cost;
                    this.upgrades[item.id]++;
                    this.saveData();
                    this.openShop();
                    this.updateUI();
                }
            };
            container.appendChild(btn);
        });
        this.toggleOverlay('shop-overlay', true);
    }
}

const game = new Game();
</script>
</body>
</html>
