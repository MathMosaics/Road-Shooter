<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Road: Ultimate Squad</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff0077;
            --neon-purple: #bc13fe;
            --neon-red: #ff3131;
            --neon-yellow: #ffcc00;
            --neon-green: #39ff14;
        }
        body { 
            margin: 0; 
            background: #050508; 
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            touch-action: none;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 242, 255, 0.1);
            background: #000;
            width: 100%;
            height: 100%;
            max-width: 500px;
        }
        canvas { 
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            z-index: 5;
        }
        .stat-box { 
            background: rgba(0,0,0,0.6); 
            padding: 10px; 
            border-radius: 8px;
            backdrop-filter: blur(8px);
        }
        .stat-label { font-size: 9px; color: var(--neon-blue); display: block; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 2px; }
        .stat-value { font-size: 18px; font-weight: 900; font-variant-numeric: tabular-nums; }

        #xp-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.05);
            z-index: 10;
        }
        #xp-bar {
            height: 100%;
            width: 0%;
            background: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            transition: width 0.3s ease;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            padding: 30px;
            box-sizing: border-box;
            backdrop-filter: blur(10px);
        }

        h2 { color: var(--neon-pink); font-size: 36px; margin: 0; text-shadow: 0 0 15px var(--neon-pink); letter-spacing: 2px; }
        
        .btn {
            padding: 18px 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid var(--neon-blue);
            background: rgba(0, 242, 255, 0.1);
            color: var(--neon-blue);
            margin: 10px;
            border-radius: 12px;
            text-transform: uppercase;
            width: 100%;
            max-width: 280px;
            pointer-events: auto;
        }
        .btn:active {
            background: var(--neon-blue);
            color: #000;
            transform: scale(0.95);
        }

        .shop-grid {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 20px 0;
            pointer-events: auto;
            max-height: 50vh;
            overflow-y: auto;
        }
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.03);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .item-name { display: block; font-size: 14px; font-weight: bold; color: var(--neon-blue); }
        .item-cost { color: var(--neon-yellow); font-weight: 900; }

        #phase-msg {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            color: var(--neon-pink);
            font-weight: 900;
            letter-spacing: 5px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="xp-container"><div id="xp-bar"></div></div>
    <div id="phase-msg">PHASE SHIFT</div>
    
    <div id="ui-layer">
        <div class="stat-box">
            <span class="stat-label">Currency</span>
            <span id="coin-display" class="stat-value">0</span>
        </div>
        <div class="stat-box" style="text-align: right;">
            <span class="stat-label">Squad Rank</span>
            <span id="rank-display" class="stat-value">1</span>
        </div>
    </div>

    <div id="menu-overlay" class="overlay" style="display: flex;">
        <h2>NEON ROAD</h2>
        <p style="color: #888; margin: 20px 0;">Optimized for mobile. Command your squad through the neon grid.</p>
        <button class="btn" onclick="game.start()">Launch Mission</button>
        <button class="btn" style="border-color: var(--neon-purple); color: var(--neon-purple);" onclick="game.openShop()">Upgrade Depot</button>
    </div>

    <div id="shop-overlay" class="overlay">
        <h2>DEPOT</h2>
        <div id="shop-items" class="shop-grid"></div>
        <button class="btn" onclick="game.toggleOverlay('shop-overlay', false)">Close</button>
    </div>

    <div id="death-overlay" class="overlay">
        <h2>SQUAD WIPED</h2>
        <p id="death-msg">Mission terminated.</p>
        <button class="btn" onclick="game.start()">Restart</button>
        <button class="btn" style="border-color: #555; color: #555;" onclick="game.toggleOverlay('death-overlay', false); game.toggleOverlay('menu-overlay', true);">Menu</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
/**
 * PERFORMANCE NOTES:
 * 1. Mobile-First Spawning: We spawn fewer, stronger "Elite" invaders to keep entity counts low.
 * 2. Particle Culling: Hard limit on active particles for iPad/Phone GPUs.
 * 3. Broad-phase Collision: Basic lane-based culling.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimization: no alpha on main context

let width, height, laneWidth;

function resize() {
    const container = document.getElementById('game-container');
    width = container.clientWidth;
    height = container.clientHeight;
    canvas.width = width;
    canvas.height = height;
    laneWidth = width / 2;
}

window.addEventListener('resize', resize);
resize();

class Game {
    constructor() {
        this.loadData();
        this.reset();
        this.setupInput();
        this.loop();
    }

    loadData() {
        const saved = localStorage.getItem('neon_road_v6');
        this.upgrades = saved ? JSON.parse(saved) : {
            multiShot: 0,
            damage: 0,
            coinGain: 0,
            fireRate: 0
        };
        this.totalCoins = parseInt(localStorage.getItem('neon_road_coins')) || 0;
    }

    saveData() {
        localStorage.setItem('neon_road_v6', JSON.stringify(this.upgrades));
        localStorage.setItem('neon_road_coins', Math.floor(this.totalCoins));
    }

    reset() {
        this.isActive = false;
        this.frame = 0;
        this.entities = [];
        this.bullets = [];
        this.particles = [];
        this.playerLane = 0;
        this.currentX = laneWidth / 2;
        this.isFiring = false;
        this.rank = 1;
        this.xp = 0;
        this.xpToNext = 100;
        this.isPhasing = false;
        this.phaseTimer = 0;
        
        // Calculated stats
        this.squadSize = 1 + this.upgrades.multiShot;
        this.fireRate = 16 - (this.upgrades.fireRate * 1.5);
        this.damage = 1 + (this.upgrades.damage * 0.4);
        
        this.updateUI();
    }

    setupInput() {
        const handleInteraction = (clientX) => {
            if (!this.isActive) return;
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const newLane = x < laneWidth ? 0 : 1;
            
            if (newLane !== this.playerLane) {
                this.isPhasing = true;
                this.phaseTimer = 20;
            }
            this.playerLane = newLane;
            this.isFiring = true;
        };

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInteraction(e.touches[0].clientX);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleInteraction(e.touches[0].clientX);
        }, { passive: false });

        canvas.addEventListener('touchend', () => this.isFiring = false);
        
        // Mouse support for dev/testing
        canvas.addEventListener('mousedown', (e) => handleInteraction(e.clientX));
        window.addEventListener('mouseup', () => this.isFiring = false);
    }

    start() {
        this.reset();
        this.isActive = true;
        this.toggleOverlay('menu-overlay', false);
        this.toggleOverlay('death-overlay', false);
    }

    toggleOverlay(id, show) {
        document.getElementById(id).style.display = show ? 'flex' : 'none';
    }

    updateUI() {
        document.getElementById('coin-display').innerText = Math.floor(this.totalCoins);
        document.getElementById('rank-display').innerText = this.rank;
        document.getElementById('xp-bar').style.width = `${(this.xp / this.xpToNext) * 100}%`;
        document.getElementById('phase-msg').style.opacity = this.isPhasing ? 1 : 0;
    }

    spawn() {
        const lane = Math.random() > 0.5 ? 1 : 0;
        const x = (lane * laneWidth) + (laneWidth / 2);
        
        // Balanced difficulty scaling
        // Instead of hundreds of monsters, we spawn 1-3 based on rank, but they are "Large"
        const rankScaling = 1 + (this.rank * 0.15);
        
        if (Math.random() > 0.7) {
            // Barrier
            const value = Math.random() > 0.8 ? -(Math.floor(Math.random()*20 + 5)) : Math.floor(Math.random()*5 + 1);
            this.entities.push({
                type: 'barrier', x, y: -50, lane, value, hp: 0, maxHp: 10 * rankScaling * this.damage,
                speed: 3 + (this.rank * 0.1)
            });
        } else {
            // Mobile-Optimized Invader (Fewer but tougher)
            const eliteRoll = Math.random();
            let type = 'grunt';
            let hp = 3 * rankScaling;
            let scale = 1.0;
            let color = '#bc13fe';

            if (eliteRoll > 0.9) {
                type = 'goliath'; hp *= 15; scale = 2.2; color = '#ff8c00';
            } else if (eliteRoll > 0.7) {
                type = 'warrior'; hp *= 4; scale = 1.4; color = '#ff0077';
            }

            this.entities.push({
                type: 'monster', id: type, x, y: -50, lane, hp, maxHp: hp, scale, color,
                speed: (3 + Math.random() * 2) * (1 + (this.rank * 0.05)),
                xp: Math.floor(10 * scale)
            });
        }
    }

    update() {
        if (!this.isActive) return;
        this.frame++;

        // Phase shift logic
        if (this.isPhasing) {
            this.phaseTimer--;
            if (this.phaseTimer <= 0) this.isPhasing = false;
        }

        // Smooth movement
        const targetX = (this.playerLane * laneWidth) + (laneWidth / 2);
        this.currentX += (targetX - this.currentX) * 0.2;

        // Spawning throttle
        const spawnRate = Math.max(15, 60 - (this.rank * 2));
        if (this.frame % spawnRate === 0) this.spawn();

        // Firing
        if (this.isFiring && this.frame % Math.floor(this.fireRate) === 0) {
            this.fire();
        }

        // Entities update
        for (let i = this.entities.length - 1; i >= 0; i--) {
            const e = this.entities[i];
            e.y += e.speed;

            // Collision with bullets
            for (let j = this.bullets.length - 1; j >= 0; j--) {
                const b = this.bullets[j];
                const dx = b.x - e.x;
                const dy = b.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const radius = e.type === 'barrier' ? 50 : 35 * e.scale;

                if (dist < radius) {
                    if (e.type === 'barrier') {
                        e.hp += this.damage;
                        if (e.hp >= e.maxHp) {
                            if (e.value > 0) this.squadSize += e.value;
                            this.createExplosion(e.x, e.y, e.value > 0 ? '#00f2ff' : '#ff3131', 8);
                            this.entities.splice(i, 1);
                        }
                    } else {
                        e.hp -= this.damage;
                        if (e.hp <= 0) {
                            this.totalCoins += 10 * e.scale;
                            this.xp += e.xp;
                            this.createExplosion(e.x, e.y, e.color, 12);
                            this.entities.splice(i, 1);
                            if (this.xp >= this.xpToNext) this.rankUp();
                        }
                    }
                    this.bullets.splice(j, 1);
                    break;
                }
            }

            // Collision with Player
            if (this.entities[i] && Math.abs(e.y - (height - 120)) < 40) {
                if (Math.abs(e.x - this.currentX) < 40) {
                    if (e.type === 'barrier') {
                        this.squadSize += e.value;
                        this.entities.splice(i, 1);
                        if (this.squadSize < 1) this.die();
                    } else if (!this.isPhasing) {
                        this.die();
                    }
                }
            }

            if (e && e.y > height + 100) this.entities.splice(i, 1);
        }

        // Bullets update
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            this.bullets[i].y -= 15;
            if (this.bullets[i].y < -50) this.bullets.splice(i, 1);
        }

        // Particles update (Hard limited to 400 for mobile stability)
        if (this.particles.length > 400) this.particles.splice(0, this.particles.length - 400);
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        if (this.frame % 30 === 0) this.updateUI();
    }

    rankUp() {
        this.rank++;
        this.xp = 0;
        this.xpToNext = Math.floor(this.xpToNext * 1.4);
        this.damage += 0.2;
        this.createExplosion(width / 2, height / 2, '#39ff14', 40);
        this.updateUI();
    }

    fire() {
        const count = Math.min(15, Math.floor(this.squadSize));
        const spacing = 20;
        const totalWidth = (count - 1) * spacing;
        for (let i = 0; i < count; i++) {
            this.bullets.push({
                x: (this.currentX - totalWidth / 2) + (i * spacing),
                y: height - 130
            });
        }
    }

    createExplosion(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y, color,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0
            });
        }
    }

    die() {
        this.isActive = false;
        this.toggleOverlay('death-overlay', true);
        this.saveData();
    }

    openShop() {
        const container = document.getElementById('shop-items');
        container.innerHTML = '';
        const items = [
            { id: 'multiShot', name: 'Add Soldier', cost: 1000 },
            { id: 'damage', name: 'Weapon Power', cost: 800 },
            { id: 'fireRate', name: 'Overclock', cost: 1500 }
        ];

        items.forEach(item => {
            const level = this.upgrades[item.id] || 0;
            const cost = item.cost * (level + 1);
            const div = document.createElement('div');
            div.className = 'shop-item';
            div.onclick = () => {
                if (this.totalCoins >= cost) {
                    this.totalCoins -= cost;
                    this.upgrades[item.id]++;
                    this.saveData();
                    this.openShop();
                    this.updateUI();
                }
            };
            div.innerHTML = `
                <div>
                    <span class="item-name">${item.name}</span>
                    <small style="color:#666">Level ${level}</small>
                </div>
                <div class="item-cost">${cost}</div>
            `;
            container.appendChild(div);
        });
        this.toggleOverlay('shop-overlay', true);
    }

    drawInvader(ctx, x, y, scale, color) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = color;
        
        // Classic Invader Shape
        ctx.beginPath();
        // Body
        ctx.fillRect(-15, -10, 30, 15);
        // Antennas
        ctx.fillRect(-10, -15, 5, 5);
        ctx.fillRect(5, -15, 5, 5);
        // Legs
        ctx.fillRect(-15, 5, 5, 5);
        ctx.fillRect(10, 5, 5, 5);
        ctx.fillRect(-5, 5, 10, 3);
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(-8, -5, 4, 4);
        ctx.fillRect(4, -5, 4, 4);
        
        ctx.restore();
    }

    draw() {
        // Clear with slight motion blur feel (darker clear)
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, width, height);

        // Draw Lanes
        ctx.strokeStyle = 'rgba(0, 242, 255, 0.05)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(laneWidth, 0); ctx.lineTo(laneWidth, height);
        ctx.stroke();

        // Draw Particles
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;

        // Draw Bullets
        ctx.fillStyle = '#fff';
        this.bullets.forEach(b => {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f2ff';
            ctx.fillRect(b.x - 2, b.y, 4, 20);
            ctx.shadowBlur = 0;
        });

        // Draw Entities
        this.entities.forEach(e => {
            if (e.type === 'barrier') {
                ctx.strokeStyle = e.value > 0 ? '#00f2ff' : '#ff3131';
                ctx.lineWidth = 3;
                ctx.strokeRect(e.x - 60, e.y - 25, 120, 50);
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(e.x - 60, e.y - 25, 120, 50);
                
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = '900 24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText((e.value > 0 ? '+' : '') + e.value, e.x, e.y + 8);
                
                // HP Bar for barriers
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(e.x - 40, e.y + 30, 80, 4);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fillRect(e.x - 40, e.y + 30, 80 * (e.hp/e.maxHp), 4);
            } else {
                this.drawInvader(ctx, e.x, e.y, e.scale, e.color);
            }
        });

        // Draw Squad
        const sCount = Math.floor(this.squadSize);
        ctx.fillStyle = this.isPhasing ? 'rgba(0, 242, 255, 0.4)' : '#00f2ff';
        for (let i = 0; i < sCount; i++) {
            const spacing = 22;
            const rowSize = 5;
            const row = Math.floor(i / rowSize);
            const col = i % rowSize;
            const x = this.currentX + (col - (Math.min(sCount, rowSize) - 1) / 2) * spacing;
            const y = height - 120 + (row * spacing);
            
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

const game = new Game();
</script>
</body>
</html>
